<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>graph.edge — Network Edge &mdash; AutoCNet</title>
    
    <link rel="stylesheet" type="text/css" href="../../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'Please install this project with setup.py',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../None"></script>
    <script type="text/javascript" src="../../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" >
    <link rel="search" title="Search" href="../../search.html" >
    <link rel="top" title="AutoCNet" href="../../index.html" >
    <link rel="up" title="graph — Graph Based Data Representaton" href="index.html" >
    <link rel="next" title="graph.markov_cluster — Markov Clustering Algorithm" href="markov_cluster.html" >
    <link rel="prev" title="graph.node — Network Node Object" href="node.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="../../index.html">AutoCNet</a></li>
	
          <li class="active"><a href="../index.html" >Library Reference</a></li>
          <li class="active"><a href="index.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">graph</span></code> — Graph Based Data Representaton</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="markov_cluster.html" title="graph.markov_cluster — Markov Clustering Algorithm"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="node.html" title="graph.node — Network Node Object"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="node.html"
                        title="previous chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">graph.node</span></code> — Network Node Object</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="markov_cluster.html"
                        title="next chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">graph.markov_cluster</span></code> — Markov Clustering Algorithm</a></p>
  <h3>This Page</h3>
  <div>
    <a href="../../_sources/library/graph/edge.rst.txt"
       rel="nofollow">Show Source</a>
  </div>
<div class="this-page-menu">
  <a href="/scipy/docs/scipy-docs/library/graph/edge.rst.rst">Edit page</a>
</div>

        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="graph-edge-network-edge">
<h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">graph.edge</span></code> — Network Edge<a class="headerlink" href="#graph-edge-network-edge" title="Permalink to this headline">¶</a></h1>
<p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">graph.edge</span></code> module contains the Edge class that extends NetworkX edges.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.1.0.</span></p>
</div>
<span class="target" id="module-autocnet.graph.edge"></span><dl class="py class">
<dt id="autocnet.graph.edge.Edge">
<em class="property">class </em><code class="sig-prename descclassname">autocnet.graph.edge.</code><code class="sig-name descname">Edge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">source</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">destination</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#Edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.Edge" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py attribute">
<dt id="autocnet.graph.edge.Edge.source">
<code class="sig-name descname">source</code><a class="headerlink" href="#autocnet.graph.edge.Edge.source" title="Permalink to this definition">¶</a></dt>
<dd><p>The source node</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>hashable</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="autocnet.graph.edge.Edge.destination">
<code class="sig-name descname">destination</code><a class="headerlink" href="#autocnet.graph.edge.Edge.destination" title="Permalink to this definition">¶</a></dt>
<dd><p>The destination node</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>hashable</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="autocnet.graph.edge.Edge.masks">
<code class="sig-name descname">masks</code><a class="headerlink" href="#autocnet.graph.edge.Edge.masks" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the available masking arrays</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>set</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="autocnet.graph.edge.Edge.weights">
<code class="sig-name descname">weights</code><a class="headerlink" href="#autocnet.graph.edge.Edge.weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary with two keys overlap_area, and overlap_percn
overlap_area returns the area overlaped by both images
overlap_percn retuns the total percentage of overlap</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="autocnet.graph.edge.Edge.add_coordinates_to_matches">
<code class="sig-name descname">add_coordinates_to_matches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#Edge.add_coordinates_to_matches"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.Edge.add_coordinates_to_matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Add source and destination x/y columns to the matches dataframe. This
will add to the overall memory needed to store matches, but makes
access to x,y easier as a join on the keypoints is not requires.</p>
</dd></dl>

<dl class="py method">
<dt id="autocnet.graph.edge.Edge.clean">
<code class="sig-name descname">clean</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">clean_keys</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#Edge.clean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.Edge.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of clean keys compute the mask of valid
matches</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>clean_keys</strong> (<em>list</em>) – of columns names (clean keys)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>matches</strong> (<em>dataframe</em>) – A masked view of the matches dataframe</p></li>
<li><p><strong>mask</strong> (<em>series</em>) – A boolean series to inflate back to the full match set</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="autocnet.graph.edge.Edge.compute_fundamental_error">
<code class="sig-name descname">compute_fundamental_error</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'equality'</span></em>, <em class="sig-param"><span class="n">clean_keys</span><span class="o">=</span><span class="default_value">[]</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#Edge.compute_fundamental_error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.Edge.compute_fundamental_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a fundamental matrix, compute the reprojective error between
a two sets of keypoints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>clean_keys</strong> (<em>list</em>) – of string keys to masking arrays
(created by calling outlier detection)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>error</strong> – of reprojective error indexed to the matches data frame</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pd.Series</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="autocnet.graph.edge.Edge.compute_fundamental_matrix">
<code class="sig-name descname">compute_fundamental_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">clean_keys</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">maskname</span><span class="o">=</span><span class="default_value">'fundamental'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#Edge.compute_fundamental_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.Edge.compute_fundamental_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the fundamental matrix (F) using the correspondences tagged to this
edge.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clean_keys</strong> (<em>list</em>) – Of strings used to apply masks to omit correspondences</p></li>
<li><p><strong>method</strong> (<em>{linear</em><em>, </em><em>nonlinear}</em>) – Method to use to compute F.  Linear is significantly faster at
the cost of reduced accuracy.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">autocnet.transformation.transformations.FundamentalMatrix()</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="autocnet.graph.edge.Edge.compute_homography">
<code class="sig-name descname">compute_homography</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'ransac'</span></em>, <em class="sig-param"><span class="n">clean_keys</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">pid</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">maskname</span><span class="o">=</span><span class="default_value">'homography'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#Edge.compute_homography"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.Edge.compute_homography" title="Permalink to this definition">¶</a></dt>
<dd><p>For each edge in the (sub) graph, compute the homography
:param outlier_algorithm: An openCV outlier detections algorithm, e.g. cv2.RANSAC
:type outlier_algorithm: object
:param clean_keys: of string keys to masking arrays</p>
<blockquote>
<div><p>(created by calling outlier detection)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>transformation_matrix</strong> (<em>ndarray</em>) – The 3x3 transformation matrix</p></li>
<li><p><strong>mask</strong> (<em>ndarray</em>) – Boolean array of the outliers</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="autocnet.graph.edge.Edge.compute_overlap">
<code class="sig-name descname">compute_overlap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">buffer_dist</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#Edge.compute_overlap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.Edge.compute_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate a source and destination minimum bounding rectangle, in
pixel space.</p>
</dd></dl>

<dl class="py method">
<dt id="autocnet.graph.edge.Edge.compute_weights">
<code class="sig-name descname">compute_weights</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">clean_keys</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#Edge.compute_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.Edge.compute_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a voronoi diagram for the overlap between two images
then gets the area of each polygon resulting in a voronoi weight.
These weights are then appended to the matches dataframe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>clean_keys</strong> (<em>list</em>) – Of strings used to apply masks to omit correspondences</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="autocnet.graph.edge.Edge.coverage">
<code class="sig-name descname">coverage</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">clean_keys</span><span class="o">=</span><span class="default_value">[]</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#Edge.coverage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.Edge.coverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Acts on the edge given either the source node
or the destination node and returns the percentage
of overlap covered by the keypoints. Data for the
overlap is gathered from the source node of the edge
resulting in a maximum area difference of 2% when compared
to the destination.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>total_overlap_percentage</strong> – returns the overlap area
covered by the keypoints</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="autocnet.graph.edge.Edge.decompose">
<code class="sig-name descname">decompose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#Edge.decompose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.Edge.decompose" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply coupled decomposition to the images and
match identified sub-images</p>
</dd></dl>

<dl class="py method">
<dt id="autocnet.graph.edge.Edge.decompose_and_match">
<code class="sig-name descname">decompose_and_match</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">k</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">maxiteration</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">size</span><span class="o">=</span><span class="default_value">18</span></em>, <em class="sig-param"><span class="n">buf_dist</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#autocnet.graph.edge.Edge.decompose_and_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to match, this method first decomposed the image into
$4^{maxiteration}$ subimages and applys matching between each sub-image.</p>
<p>This method is potential slower than the standard match due to the
overhead in matching, but can be significantly more accurate.  The
increase in accuracy is a function of the total image size.  Suggested
values for maxiteration are provided below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<em>int</em>) – The number of neighbors to find</p></li>
<li><p><strong>method</strong> (<em>{'coupled'</em><em>, </em><em>'whole'}</em>) – whether to utilize coupled decomposition
or match the whole image</p></li>
<li><p><strong>maxiteration</strong> (<em>int</em>) – <p>When using coupled decomposition, the number of recursive
divisions to apply.  The total number of resultant
sub-images will be 4 ** maxiteration.  Approximate values:</p>
<blockquote>
<div><div class="line-block">
<div class="line">Number of megapixels | maxiteration |</div>
</div>
<p><a href="#id1"><span class="problematic" id="id2">|----------------------|</span></a>————–|
| m &lt; 10               <a href="#id3"><span class="problematic" id="id4">|1-2|</span></a>
| 10 &lt; m &lt; 30          | 3 |
| 30 &lt; m &lt; 100         | 4 |
| 100 &lt; m &lt; 1000       | 5 |
| m &gt; 1000             | 6 |</p>
</div></blockquote>
</p></li>
<li><p><strong>size</strong> (<em>int</em>) – When using coupled decomposition, the total number of points
to check in each sub-image to try and find a match.
Selection of this number is a balance between seeking a
representative mid-point and computational cost.</p></li>
<li><p><strong>buf_dist</strong> (<em>int</em>) – When using coupled decomposition, the distance from the edge of
the (sub)image a point must be in order to be used as a
partioning point.  The smaller the distance, the more likely
percision errors can results in erroneous partitions.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="autocnet.graph.edge.Edge.match">
<code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">k</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#Edge.match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.Edge.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two sets of descriptors, utilize a FLANN (Approximate Nearest
Neighbor KDTree) matcher to find the k nearest matches.  Nearness is
the euclidean distance between descriptors.</p>
<p>The matches are then added as an attribute to the edge object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>k</strong> (<em>int</em>) – The number of neighbors to find</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="autocnet.graph.edge.Edge.overlap">
<code class="sig-name descname">overlap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#Edge.overlap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.Edge.overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Acts on an edge and returns the overlap area and percentage of overlap
between the two images on the edge. Data is returned to the
weights dictionary</p>
</dd></dl>

<dl class="py method">
<dt id="autocnet.graph.edge.Edge.overlap_check">
<code class="sig-name descname">overlap_check</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#Edge.overlap_check"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.Edge.overlap_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a mask for matches on the overlap</p>
</dd></dl>

<dl class="py method">
<dt id="autocnet.graph.edge.Edge.project_matches">
<code class="sig-name descname">project_matches</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">semimajor</span></em>, <em class="sig-param"><span class="n">semiminor</span></em>, <em class="sig-param"><span class="n">on</span><span class="o">=</span><span class="default_value">'source'</span></em>, <em class="sig-param"><span class="n">srid</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#Edge.project_matches"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.Edge.project_matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Project matches.</p>
</dd></dl>

<dl class="py method">
<dt id="autocnet.graph.edge.Edge.subpixel_register">
<code class="sig-name descname">subpixel_register</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'phase'</span></em>, <em class="sig-param"><span class="n">clean_keys</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">template_size</span><span class="o">=</span><span class="default_value">251</span></em>, <em class="sig-param"><span class="n">search_size</span><span class="o">=</span><span class="default_value">251</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#Edge.subpixel_register"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.Edge.subpixel_register" title="Permalink to this definition">¶</a></dt>
<dd><p>For the entire graph, compute the subpixel offsets using pattern-matching and add the result
as an attribute to each edge of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clean_keys</strong> (<em>list</em>) – of string keys to masking arrays
(created by calling outlier detection)</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – On the range [-1, 1].  Values less than or equal to
this threshold are masked and can be considered
outliers</p></li>
<li><p><strong>upsampling</strong> (<em>int</em>) – The multiplier to the template and search shapes to upsample
for subpixel accuracy</p></li>
<li><p><strong>template_size</strong> (<em>int</em>) – The size of the template in pixels, must be odd. If using phase,
only the template size is used.</p></li>
<li><p><strong>search_size</strong> (<em>int</em>) – The size of the search area. When method=’template’, this size should
be &gt;= the template size</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="autocnet.graph.edge.Edge.suppress">
<code class="sig-name descname">suppress</code><span class="sig-paren">(</span><em class="sig-param">suppression_func=&lt;function correlation&gt;</em>, <em class="sig-param">clean_keys=[]</em>, <em class="sig-param">maskname='suppression'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#Edge.suppress"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.Edge.suppress" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a disc based suppression algorithm to get a good spatial
distribution of high quality points, where the user defines some
function to be used as the quality metric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>suppression_func</strong> (<em>object</em>) – A function that returns a scalar value to be used
as the strength of a given row in the matches data
frame.</p></li>
<li><p><strong>suppression_args</strong> (<em>tuple</em>) – Arguments to be passed on to the suppression function</p></li>
<li><p><strong>clean_keys</strong> (<em>list</em>) – of mask keys to be used to reduce the total size
of the matches dataframe.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="autocnet.graph.edge.NetworkEdge">
<em class="property">class </em><code class="sig-prename descclassname">autocnet.graph.edge.</code><code class="sig-name descname">NetworkEdge</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#NetworkEdge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.NetworkEdge" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="autocnet.graph.edge.NetworkEdge.mask_to_counter">
<code class="sig-name descname">mask_to_counter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mask</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#NetworkEdge.mask_to_counter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.NetworkEdge.mask_to_counter" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a mask on an edge and convert the mask into a counter where
the key is the match id and value is 1 (the match is flagged false).</p>
<p>TODO: Allow the mask to be an iterable (list). The caller of this should
then worry about normalization as n-mask strings can come in and we
cannot anticipate how the user might want to normalize the return.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mask</strong> (<em>str</em>) – The name of the mask</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>With keys equal to the indices of the False matches
and values equal to one</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>collections.Counter</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="autocnet.graph.edge.NetworkEdge.network_to_matches">
<code class="sig-name descname">network_to_matches</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ignore_point</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ignore_measure</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">rejected_jigsaw</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/autocnet/graph/edge.html#NetworkEdge.network_to_matches"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#autocnet.graph.edge.NetworkEdge.network_to_matches" title="Permalink to this definition">¶</a></dt>
<dd><p>For the edge, take any points/measures that are in the database and
convert them into matches on the associated edge.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ignore_point</strong> (<em>bool</em>) – If False (default) only select the points that are
not ignored (currently active).</p></li>
<li><p><strong>ignore_measure</strong> (<em>bool</em>) – If False (default) only add the measures that are
not ignored (currently active).</p></li>
<li><p><strong>rejected_jigsaw</strong> (<em>bool</em>) – If False (default) add any points that are not
set to jigsaw rejected.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2017 - , AutoCNetDevelopers.
      </li>
      <li>
      Last updated on Jul 27, 2020.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 3.1.2.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>