<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>autocnet.transformation.fundamental_matrix &mdash; AutoCNet</title>
    
    <link rel="stylesheet" type="text/css" href="../../../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../../../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../../../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     'Please install this project with setup.py',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../None"></script>
    <script type="text/javascript" src="../../../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" >
    <link rel="search" title="Search" href="../../../search.html" >
    <link rel="top" title="AutoCNet" href="../../../index.html" >
    <link rel="up" title="Module code" href="../../index.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="../../../index.html">AutoCNet</a></li>
	
          <li class="active"><a href="../../index.html" accesskey="U">Module code</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../../../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../../../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">

        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <h1>Source code for autocnet.transformation.fundamental_matrix</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>
<span class="kn">from</span> <span class="nn">autocnet.camera</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="kn">from</span> <span class="nn">autocnet.camera</span> <span class="kn">import</span> <span class="n">utils</span> <span class="k">as</span> <span class="n">camera_utils</span>
<span class="kn">from</span> <span class="nn">autocnet.utils.utils</span> <span class="kn">import</span> <span class="n">make_homogeneous</span><span class="p">,</span> <span class="n">normalize_vector</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cv2</span>
    <span class="n">cv2_avail</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="n">cv_avail</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="compute_epipolar_lines"><a class="viewcode-back" href="../../../library/transformation/fundamental.html#autocnet.transformation.fundamental_matrix.compute_epipolar_lines">[docs]</a><span class="k">def</span> <span class="nf">compute_epipolar_lines</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a fundamental matrix and a set of homogeneous points</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    F : ndarray</span>
<span class="sd">        of shape (3,3) that represents the fundamental matrix</span>

<span class="sd">    x : ndarray</span>
<span class="sd">        of shape (n, 3) of homogeneous coordinates</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lines : ndarray</span>
<span class="sd">            of shape (n,3) of epipolar lines in standard form</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">values</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The input points must be homogenous with shape (n,3)&#39;</span><span class="p">)</span>

    <span class="c1"># Compute the unnormalized epipolar lines</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Normalize the lines</span>
    <span class="n">nu</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">lines</span> <span class="o">*=</span> <span class="n">nu</span>

    <span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

    <span class="c1"># Inner transposes the result, so transpose back into the 3 column form</span>
    <span class="k">return</span> <span class="n">lines</span></div>

<div class="viewcode-block" id="epipolar_distance"><a class="viewcode-back" href="../../../library/transformation/fundamental.html#autocnet.transformation.fundamental_matrix.epipolar_distance">[docs]</a><span class="k">def</span> <span class="nf">epipolar_distance</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">pts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a set of epipolar lines and a set of points, compute the euclidean</span>
<span class="sd">    distance between each point and the corresponding epipolar line</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lines : ndarray</span>
<span class="sd">            of shape (n,3) of epipolar lines in standard form</span>

<span class="sd">    pts : ndarray</span>
<span class="sd">          of shape (n, 3) of homogeneous coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lines</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">lines</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lines</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lines</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">lines</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">num</span> <span class="o">/</span> <span class="n">denom</span></div>

<div class="viewcode-block" id="compute_reprojection_error"><a class="viewcode-back" href="../../../library/transformation/fundamental.html#autocnet.transformation.fundamental_matrix.compute_reprojection_error">[docs]</a><span class="k">def</span> <span class="nf">compute_reprojection_error</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a set of matches and a known fundamental matrix,</span>
<span class="sd">    compute distance between match points and the associated</span>
<span class="sd">    epipolar lines.</span>

<span class="sd">    The distance between a point and the associated epipolar</span>
<span class="sd">    line is computed as: $d = \frac{\lvert ax_{0} + by_{0} + c \rvert}{\sqrt{a^{2} + b^{2}}}$.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    F : ndarray</span>
<span class="sd">        (3,3) Fundamental matrix</span>

<span class="sd">    x : arraylike</span>
<span class="sd">        (n,2) or (n,3) array of homogeneous coordinates</span>

<span class="sd">    x1 : arraylike</span>
<span class="sd">        (n,2) or (n,3) array of homogeneous coordinates with the same</span>
<span class="sd">        length as argument x</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    F_error : ndarray</span>
<span class="sd">              n,1 vector of reprojection errors</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">x1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The input points must be homogenous with shape (n,3)&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">values</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)):</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">values</span>

    <span class="c1"># Compute the epipolar lines</span>
    <span class="n">lines1</span> <span class="o">=</span> <span class="n">compute_epipolar_lines</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
    <span class="n">lines2</span> <span class="o">=</span> <span class="n">compute_epipolar_lines</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>

    <span class="c1"># Compute the euclidean distance from the pt to the line</span>
    <span class="n">d1</span> <span class="o">=</span> <span class="n">epipolar_distance</span><span class="p">(</span><span class="n">lines2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="n">epipolar_distance</span><span class="p">(</span><span class="n">lines1</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>

    <span class="c1"># Grab the max err from either reprojection</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">d1</span><span class="p">,</span><span class="n">d2</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">err</span></div>

<div class="viewcode-block" id="compute_fundamental_error"><a class="viewcode-back" href="../../../library/transformation/fundamental.html#autocnet.transformation.fundamental_matrix.compute_fundamental_error">[docs]</a><span class="k">def</span> <span class="nf">compute_fundamental_error</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the fundamental error using the idealized error metric.</span>

<span class="sd">    Ideal error is defined by $x^{\intercal}Fx = 0$,</span>
<span class="sd">    where $x$ are all matchpoints in a given image and</span>
<span class="sd">    $x^{\intercal}F$ defines the standard form of the</span>
<span class="sd">    epipolar line in the second image.</span>

<span class="sd">    This method assumes that x and x1 are ordered such that x[0]</span>
<span class="sd">    correspondes to x1[0].</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    F : ndarray</span>
<span class="sd">        (3,3) Fundamental matrix</span>

<span class="sd">    x : arraylike</span>
<span class="sd">        (n,2) or (n,3) array of homogeneous coordinates</span>

<span class="sd">    x1 : arraylike</span>
<span class="sd">        (n,2) or (n,3) array of homogeneous coordinates with the same</span>
<span class="sd">        length as argument x</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    F_error : ndarray</span>
<span class="sd">              n,1 vector of reprojection errors</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO: Can this be vectorized for performance?</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">make_homogeneous</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">make_homogeneous</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">values</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">values</span>

    <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">err</span></div>

<div class="viewcode-block" id="update_fundamental_mask"><a class="viewcode-back" href="../../../library/transformation/fundamental.html#autocnet.transformation.fundamental_matrix.update_fundamental_mask">[docs]</a><span class="k">def</span> <span class="nf">update_fundamental_mask</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;reprojection&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a Fundamental matrix and two sets of points, compute the</span>
<span class="sd">    reprojection error between x1 and x2.  A mask is returned with all</span>
<span class="sd">    repojection errors greater than the error set to false.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    F : ndarray</span>
<span class="sd">        (3,3) Fundamental matrix</span>

<span class="sd">    x1 : arraylike</span>
<span class="sd">         (n,2) or (n,3) array of homogeneous coordinates</span>

<span class="sd">    x2 : arraylike</span>
<span class="sd">         (n,2) or (n,3) array of homogeneous coordinates</span>

<span class="sd">    threshold : float</span>
<span class="sd">                The new upper limit for error.  If using</span>
<span class="sd">                reprojection this is measured in pixels (the default).  If</span>
<span class="sd">                using fundamental, the idealized error is 0.  Values +- 0.05</span>
<span class="sd">                should be good.</span>

<span class="sd">    index : ndarray</span>
<span class="sd">            Optional index for mapping between reprojective error</span>
<span class="sd">            and an associated dataframe (e.g., an indexed matches dataframe).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask : dataframe</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;reprojection&#39;</span><span class="p">:</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">compute_reprojection_error</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;fundamental&#39;</span><span class="p">:</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">compute_fundamental_error</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Unknown error method.  Options are &quot;reprojection&quot; or &quot;fundamental&quot;.&#39;</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;fundamental&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>

    <span class="k">return</span> <span class="n">mask</span></div>

<div class="viewcode-block" id="enforce_singularity_constraint"><a class="viewcode-back" href="../../../library/transformation/fundamental.html#autocnet.transformation.fundamental_matrix.enforce_singularity_constraint">[docs]</a><span class="k">def</span> <span class="nf">enforce_singularity_constraint</span><span class="p">(</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The fundamental matrix should be rank 2.  In instances when it is not,</span>
<span class="sd">    the singularity constraint should be enforced.  This is forces epipolar lines</span>
<span class="sd">    to be conincident.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    F : ndarray</span>
<span class="sd">        (3,3) Fundamental Matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    F : ndarray</span>
<span class="sd">        (3,3) Singular Fundamental Matrix</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [Hartley2003]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">vt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vt</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">F</span></div>

<div class="viewcode-block" id="compute_fundamental_matrix"><a class="viewcode-back" href="../../../library/transformation/fundamental.html#autocnet.transformation.fundamental_matrix.compute_fundamental_matrix">[docs]</a><span class="k">def</span> <span class="nf">compute_fundamental_matrix</span><span class="p">(</span><span class="n">kp1</span><span class="p">,</span> <span class="n">kp2</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;mle&#39;</span><span class="p">,</span> <span class="n">reproj_threshold</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
                               <span class="n">confidence</span><span class="o">=</span><span class="mf">0.99</span><span class="p">,</span> <span class="n">mle_reproj_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given two arrays of keypoints compute the fundamental matrix.  This function</span>
<span class="sd">    accepts two dataframe of keypoints that have</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    kp1 : arraylike</span>
<span class="sd">          (n, 2) of coordinates from the source image</span>

<span class="sd">    kp2 : ndarray</span>
<span class="sd">          (n, 2) of coordinates from the destination image</span>


<span class="sd">    method : {&#39;ransac&#39;, &#39;lmeds&#39;, &#39;normal&#39;, &#39;8point&#39;}</span>
<span class="sd">              The openCV algorithm to use for outlier detection</span>

<span class="sd">    reproj_threshold : float</span>
<span class="sd">                       The maximum distances in pixels a reprojected points</span>
<span class="sd">                       can be from the epipolar line to be considered an inlier</span>

<span class="sd">    confidence : float</span>
<span class="sd">                 [0, 1] that the estimated matrix is correct</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    F : ndarray</span>
<span class="sd">        A 3x3 fundamental matrix</span>

<span class="sd">    mask : pd.Series</span>
<span class="sd">           A boolean mask identifying those points that are valid.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    While the method is user definable, if the number of input points</span>
<span class="sd">    is &lt; 7, normal outlier detection is automatically used, if 7 &gt; n &gt; 15,</span>
<span class="sd">    least medians is used, and if 7 &gt; 15, ransac can be used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mle&#39;</span><span class="p">:</span>
        <span class="c1"># Grab an initial estimate using RANSAC, then apply MLE</span>
        <span class="n">method_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">FM_RANSAC</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ransac&#39;</span><span class="p">:</span>
        <span class="n">method_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">FM_RANSAC</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;lmeds&#39;</span><span class="p">:</span>
        <span class="n">method_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">FM_LMEDS</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span>
        <span class="n">method_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">FM_7POINT</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;8point&#39;</span><span class="p">:</span>
        <span class="n">method_</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">FM_8POINT</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown estimation method. Choices are: &#39;lme&#39;, &#39;ransac&#39;, &#39;lmeds&#39;, &#39;8point&#39;, or &#39;normal&#39;.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kp1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">kp2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;F-matix computation failed. One of the keypoint args is empty. kp1:</span><span class="si">{}</span><span class="s2">, kp2:</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kp1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">kp2</span><span class="p">)))</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="c1"># OpenCV wants arrays</span>
    <span class="k">try</span><span class="p">:</span> <span class="c1"># OpenCV &lt; 3.4.1</span>
        <span class="n">F</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findFundamentalMat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kp1</span><span class="p">),</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kp2</span><span class="p">),</span>
                                         <span class="n">method_</span><span class="p">,</span>
                                         <span class="n">param1</span><span class="o">=</span><span class="n">reproj_threshold</span><span class="p">,</span>
                                         <span class="n">param2</span><span class="o">=</span><span class="n">confidence</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span> <span class="c1"># OpenCV &gt;= 3.4.1</span>
        <span class="n">F</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findFundamentalMat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kp1</span><span class="p">),</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kp2</span><span class="p">),</span>
                                         <span class="n">method_</span><span class="p">,</span>
                                         <span class="n">ransacReprojThreshold</span><span class="o">=</span><span class="n">reproj_threshold</span><span class="p">,</span>
                                         <span class="n">confidence</span><span class="o">=</span><span class="n">confidence</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">F</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;F computation failed with no result. Returning None.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">F</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;F computation fell back to 7-point algorithm, not setting F.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="c1"># Ensure that the singularity constraint is met</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">enforce_singularity_constraint</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># Enforce dimensionality</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span>  <span class="c1"># pragma: no cover</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mle&#39;</span><span class="p">:</span>
        <span class="c1"># Now apply the gold standard algorithm to refine F</span>

        <span class="k">if</span> <span class="n">kp1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">kp1</span> <span class="o">=</span> <span class="n">make_homogeneous</span><span class="p">(</span><span class="n">kp1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kp2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">kp2</span> <span class="o">=</span> <span class="n">make_homogeneous</span><span class="p">(</span><span class="n">kp2</span><span class="p">)</span>

        <span class="c1"># Generate an idealized and to be updated camera model</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">camera</span><span class="o">.</span><span class="n">camera_from_f</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">camera</span><span class="o">.</span><span class="n">idealized_camera</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">kp1</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span><span class="mi">12</span> <span class="ow">or</span> <span class="n">kp2</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span><span class="mi">12</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Unable to apply MLE.  Not enough correspondences.  Returning with a RANSAC computed F matrix.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">F</span><span class="p">,</span> <span class="n">mask</span>

        <span class="c1"># Apply Levenber-Marquardt to perform a non-linear lst. squares fit</span>
        <span class="c1">#  to minimize triangulation error (this is a local bundle)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">least_squares</span><span class="p">(</span><span class="n">camera</span><span class="o">.</span><span class="n">projection_error</span><span class="p">,</span> <span class="n">p1</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                        <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">kp1</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">kp2</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">),</span>
                                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;lm&#39;</span><span class="p">)</span>

        <span class="n">gold_standard_p</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="c1"># SciPy Lst. Sq. requires a vector, camera is 3x4</span>
        <span class="n">optimality</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">optimality</span>
        <span class="n">gold_standard_f</span> <span class="o">=</span> <span class="n">camera_utils</span><span class="o">.</span><span class="n">crossform</span><span class="p">(</span><span class="n">gold_standard_p</span><span class="p">[:,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">gold_standard_p</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">])</span>

        <span class="n">F</span> <span class="o">=</span> <span class="n">gold_standard_f</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">update_fundamental_mask</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">kp1</span><span class="p">,</span> <span class="n">kp2</span><span class="p">,</span>
                                       <span class="n">threshold</span><span class="o">=</span><span class="n">mle_reproj_threshold</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

    <span class="k">return</span> <span class="n">F</span><span class="p">,</span> <span class="n">mask</span></div>
</pre></div>

          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2017 - , AutoCNetDevelopers.
      </li>
      <li>
      Last updated on Jul 27, 2020.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 3.1.2.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>