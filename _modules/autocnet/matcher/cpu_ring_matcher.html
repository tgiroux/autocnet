<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>autocnet.matcher.cpu_ring_matcher &mdash; AutoCNet</title>
    
    <link rel="stylesheet" type="text/css" href="../../../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../../../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../../../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     'Please install this project with setup.py',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../None"></script>
    <script type="text/javascript" src="../../../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" >
    <link rel="search" title="Search" href="../../../search.html" >
    <link rel="top" title="AutoCNet" href="../../../index.html" >
    <link rel="up" title="Module code" href="../../index.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="../../../index.html">AutoCNet</a></li>
	
          <li class="active"><a href="../../index.html" accesskey="U">Module code</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../../../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../../../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">

        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <h1>Source code for autocnet.matcher.cpu_ring_matcher</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<div class="viewcode-block" id="check_pidx_duplicates"><a class="viewcode-back" href="../../../library/matcher/cpu_ring_matcher.html#autocnet.matcher.cpu_ring_matcher.check_pidx_duplicates">[docs]</a><span class="k">def</span> <span class="nf">check_pidx_duplicates</span><span class="p">(</span><span class="n">pidx</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a ring match generted set of indices, </span>
<span class="sd">    apply outlier detection to ensure no duplicates</span>
<span class="sd">    exist in either the reference column or the</span>
<span class="sd">    source column. If duplicates do exist, remove the </span>
<span class="sd">    rows; the solution is ambiguous.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check for duplicates</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">pidx</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">clean</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">pidx</span> <span class="o">=</span> <span class="n">pidx</span><span class="p">[</span><span class="n">clean</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">l</span> <span class="o">=</span> <span class="n">pidx</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">clean</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">pidx</span> <span class="o">=</span> <span class="n">pidx</span><span class="p">[</span><span class="n">clean</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">pidx</span></div>

<div class="viewcode-block" id="ransac_permute"><a class="viewcode-back" href="../../../library/matcher/cpu_ring_matcher.html#autocnet.matcher.cpu_ring_matcher.ransac_permute">[docs]</a><span class="k">def</span> <span class="nf">ransac_permute</span><span class="p">(</span><span class="n">ref_points</span><span class="p">,</span> <span class="n">tar_points</span><span class="p">,</span> <span class="n">tolerance_val</span><span class="p">,</span> <span class="n">target_points</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a set of reference points and target points, compute the</span>
<span class="sd">    geometric distances between pairs of points in the reference set</span>
<span class="sd">    and pairs of points in the target set.  Points for which the ratio of</span>
<span class="sd">    the distances is within plus or minus 1 - tolerance_value are considered</span>
<span class="sd">    to be good matches.</span>

<span class="sd">    If a valid solution is not found, this func returns three empty lists.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ref_points : ndarray</span>
<span class="sd">                 A (n, 2) array of points where the first column is the x</span>
<span class="sd">                 pixel location and the second column is the y pixel location.</span>
<span class="sd">                 Additional columns are ignored. These points are from one</span>
<span class="sd">                 image.</span>

<span class="sd">    tar_points : ndarray</span>
<span class="sd">                 A (n,2) array as above, for a second image.</span>

<span class="sd">    tolerance_value : float</span>
<span class="sd">                      On the range [-1, 1], the computed ratio must be</span>
<span class="sd">                      within 1 +- tolerance to be considered a match</span>

<span class="sd">    target_points : int</span>
<span class="sd">                    The minimum number of points required to return</span>
<span class="sd">                    a valid answer</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ref_points : ndarray</span>
<span class="sd">                 (n,2) subset of the input ref_points</span>

<span class="sd">    tar_points : ndarray</span>
<span class="sd">                 (n,2) subset of the input tar points</span>

<span class="sd">    f2 : ndarray</span>
<span class="sd">         of indices for valid points</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    P. Sidiropoulos and J.-P. Muller, A systematic solution to multi-instrument co-registration of high-resolution planetary images to an orthorectified baseline, IEEE Transactions on Geoscience and Remote Sensing, 2017</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_points</span><span class="p">)</span>
    <span class="c1"># Build an n,n distance matrix to store pairwise point distances</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">vr1</span> <span class="o">=</span> <span class="n">ref_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">vt1</span> <span class="o">=</span> <span class="n">tar_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="c1"># These are diagonals so always zero</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">continue</span>
            <span class="c1"># Compute the distance between ref_b - ref_a and tar_b - tar_a. The</span>
            <span class="c1"># absolute value should be small as these points should be sp</span>
            <span class="n">vr2</span> <span class="o">=</span> <span class="n">ref_points</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">vt2</span> <span class="o">=</span> <span class="n">tar_points</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="n">dr</span> <span class="o">=</span> <span class="n">vr2</span> <span class="o">-</span> <span class="n">vr1</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">vt2</span> <span class="o">-</span> <span class="n">vt1</span>

            <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">/</span> <span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
    <span class="c1"># Compute min/max bounds for the tolerance</span>
    <span class="n">minlim</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">tolerance_val</span>
    <span class="n">maxlim</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tolerance_val</span>

    <span class="c1"># Determine which points are within the tolerance</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">minlim</span>
    <span class="n">q2</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">maxlim</span>
    <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">q1</span><span class="o">*</span><span class="n">q2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
    <span class="c1"># How many points are within the tolerance?</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># If the number of points within the tolerance are greater than the number of desired points</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">target_points</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target_points</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
        <span class="n">qm</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="n">target_points</span>
        <span class="n">sqm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">qm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">sqm</span><span class="p">)</span>
        <span class="n">f2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">qm</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ref_points</span><span class="p">[</span><span class="n">f2</span><span class="p">],</span> <span class="n">tar_points</span><span class="p">[</span><span class="n">f2</span><span class="p">],</span> <span class="n">f2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="sift_match"><a class="viewcode-back" href="../../../library/matcher/cpu_ring_matcher.html#autocnet.matcher.cpu_ring_matcher.sift_match">[docs]</a><span class="k">def</span> <span class="nf">sift_match</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    vl_ubcmatch from the vlfeat toolbox for MatLab.  This is</span>
<span class="sd">    Lowe&#39;s prescribed implementation for disambiguating descriptors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : np.ndarray</span>
<span class="sd">        (m,) a singular descriptors where the m-dimension are the</span>
<span class="sd">        descriptor lengths.  For SIFT m=128. This is reshaped from</span>
<span class="sd">        a vector to an array.</span>
<span class="sd">    b : np.ndarray</span>
<span class="sd">        (n,m) where the n-dimension are the individual features and</span>
<span class="sd">        the m-dimension are the elements of the descriptor.</span>

<span class="sd">    thresh : float</span>
<span class="sd">             The threshold for disambiguating correspondences. From Lowe.</span>
<span class="sd">             If best * thresh &lt; second_best, a match has been found.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    best : int</span>
<span class="sd">           Index for the best match</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    P. Sidiropoulos and J.-P. Muller, A systematic solution to multi-instrument co-registration of high-resolution planetary images to an orthorectified baseline, IEEE Transactions on Geoscience and Remote Sensing, 2017</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">best</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="n">dists</span> <span class="o">!=</span> <span class="n">dists</span><span class="p">[</span><span class="n">best</span><span class="p">]])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>  <span class="c1"># Edge case where all descriptors are the same</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="n">dists</span> <span class="o">==</span> <span class="n">dists</span><span class="p">[</span><span class="n">best</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>  <span class="c1"># Edge case where the best is ambiguous</span>
    <span class="n">sec_best</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="n">dists</span> <span class="o">!=</span> <span class="n">dists</span><span class="p">[</span><span class="n">best</span><span class="p">]])</span>

    <span class="k">if</span> <span class="n">dists</span><span class="p">[</span><span class="n">best</span><span class="p">]</span> <span class="o">*</span> <span class="n">thresh</span> <span class="o">&lt;</span> <span class="n">sec_best</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">best</span>
    <span class="k">return</span></div>

<div class="viewcode-block" id="ring_match"><a class="viewcode-back" href="../../../library/matcher/cpu_ring_matcher.html#autocnet.matcher.cpu_ring_matcher.ring_match">[docs]</a><span class="k">def</span> <span class="nf">ring_match</span><span class="p">(</span><span class="n">ref_feats</span><span class="p">,</span> <span class="n">tar_feats</span><span class="p">,</span> <span class="n">ref_desc</span><span class="p">,</span> <span class="n">tar_desc</span><span class="p">,</span> <span class="n">ring_radius</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span>
               <span class="n">max_radius</span><span class="o">=</span><span class="mi">40000</span><span class="p">,</span> <span class="n">target_points</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">tolerance_val</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span>
               <span class="n">iteration_break_point</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply the University College London ring matching technique that seeks to match</span>
<span class="sd">    target feats to a number of reference features.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ref_feats : np.ndarray</span>
<span class="sd">                where the first 2 columns are the x,y coordinates in pixel space,</span>
<span class="sd">                columns 3 &amp; 4 are the x,y coordinates in m or km in the same</span>
<span class="sd">                reference as the target features</span>

<span class="sd">    tar_feats : np.ndarray</span>
<span class="sd">                where the first 2 columns are the x,y coordinates in pixel space,</span>
<span class="sd">                columns 3 &amp; 4 are the x,y coordinates in m or km in the same</span>
<span class="sd">                reference as the reference features</span>

<span class="sd">    ref_desc : np.ndarray</span>
<span class="sd">               (m, n) where m are the individual SIFT features and</span>
<span class="sd">               n are the descriptor length (usually 128)</span>

<span class="sd">    tar_desc : np.ndarray</span>
<span class="sd">               (m, n) where m are the individual SIFT features and</span>
<span class="sd">               n are the descriptor length (usually 128)</span>

<span class="sd">    ring_radius : numeric</span>
<span class="sd">                  The width of a ring for matching. In the same units as the x,y</span>
<span class="sd">                  coordinates for the features, e.g. if the ref_feats and tar_feats</span>
<span class="sd">                  are provided in pixel space and meters, the ring_radius should</span>
<span class="sd">                  be expressed in meters</span>

<span class="sd">    max_radius : numeric</span>
<span class="sd">                 The maximum radius to be tested.  This is the maxixum distance</span>
<span class="sd">                 a given correspondence could be from the initial estimate.</span>

<span class="sd">    target_points : int</span>
<span class="sd">                    The number of points that constitute a valid match</span>

<span class="sd">    tolerance : float</span>
<span class="sd">                The tolerance for outlier detection in point ordering between estimated</span>
<span class="sd">                resolutions</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xref : ndarray</span>
<span class="sd">           (n,4) array of the correspondences selected from the ref_feats input</span>

<span class="sd">    xtar : ndarray</span>
<span class="sd">           (n,4) array of the correspondences selected from the tar_feats input</span>

<span class="sd">    p_idx : ndarray</span>
<span class="sd">            (n,2) array of the indices in the ref_feats and tar_feats input arrays</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    P. Sidiropoulos and J.-P. Muller, A systematic solution to multi-instrument co-registration of high-resolution planetary images to an orthorectified baseline, IEEE Transactions on Geoscience and Remote Sensing, 2017</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Reference and target features</span>
    <span class="n">ref_xy</span> <span class="o">=</span> <span class="n">ref_feats</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">ref_xmym</span> <span class="o">=</span> <span class="n">ref_feats</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">tar_xy</span> <span class="o">=</span> <span class="n">tar_feats</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">tar_xmym</span> <span class="o">=</span> <span class="n">tar_feats</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
    
    <span class="c1"># Boolean mask for those reference points that have already been matched</span>
    <span class="n">ref_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_xy</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
 
    <span class="c1"># Counters</span>
    <span class="n">numr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_feats</span><span class="p">)</span>
    <span class="n">rad_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_radius</span> <span class="o">/</span> <span class="n">ring_radius</span><span class="p">)</span> <span class="c1"># Number of radial rings</span>
    <span class="n">points_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">rad_num</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>  <span class="c1"># Number of points per ring vector</span>
    <span class="n">metr</span> <span class="o">=</span> <span class="mi">1</span>
    
    <span class="c1"># Initial array for holding candidate points</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">target_points</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">rad_num</span><span class="p">))</span>
    <span class="n">p_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">target_points</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rad_num</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">ref_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="c1"># Grab a random reference point</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numr</span><span class="p">)[</span><span class="n">ref_mask</span><span class="p">])</span>
        <span class="n">current_ref_desc</span> <span class="o">=</span> <span class="n">ref_desc</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
        <span class="n">current_ref_xy</span> <span class="o">=</span> <span class="n">ref_xy</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
        <span class="n">current_ref_xmym</span> <span class="o">=</span> <span class="n">ref_xmym</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
        <span class="c1"># Compute the euclidean distance between the reference point and all targets</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">current_ref_xmym</span> <span class="o">-</span> <span class="n">tar_xmym</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># For each point, independently match to a point in a given ring</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rad_num</span><span class="p">):</span>
            <span class="c1"># The number of points that are within a given ring</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">points_in_ring</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">ring_radius</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ring_radius</span><span class="p">)</span>
            <span class="c1"># If we have enough points, run the sift matcher and select the best point, updating p</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">target_points</span><span class="p">:</span>
                <span class="c1"># All candidate points that are in the ring</span>
                <span class="n">current_tar_descs</span> <span class="o">=</span> <span class="n">tar_desc</span><span class="p">[</span><span class="n">z</span><span class="p">]</span>  <span class="c1"># This slicing uses ~25% of processing timr</span>
                <span class="n">current_tar_xys</span> <span class="o">=</span> <span class="n">tar_xy</span><span class="p">[</span><span class="n">z</span><span class="p">]</span>
                <span class="n">z_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># Sift Match</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">sift_match</span><span class="p">(</span><span class="n">current_ref_desc</span><span class="p">,</span> <span class="n">current_tar_descs</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>  <span class="c1"># The remaining 75% of processing time.</span>
                <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">points_num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">dynamically_grow_array</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">target_points</span><span class="p">)</span>
                        <span class="n">p_idx</span> <span class="o">=</span> <span class="n">dynamically_grow_array</span><span class="p">(</span><span class="n">p_idx</span><span class="p">,</span> <span class="n">target_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
                    <span class="n">p</span><span class="p">[</span><span class="n">points_num</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">:</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_ref_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">current_ref_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">current_tar_xys</span><span class="p">[</span><span class="n">match</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">current_tar_xys</span><span class="p">[</span><span class="n">match</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="c1"># Set the id of the point</span>
                    <span class="n">p_idx</span><span class="p">[</span><span class="n">points_num</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">z_idx</span><span class="p">[</span><span class="n">match</span><span class="p">]]</span>
                    <span class="n">points_num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">metr</span> <span class="o">%</span> <span class="n">iteration_break_point</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ref_mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">max_cons</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="c1"># Find all candidate rings</span>
            <span class="n">candidate_rings</span> <span class="o">=</span> <span class="n">points_num</span> <span class="o">&gt;=</span> <span class="n">target_points</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rad_num</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">candidate_rings</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="c1"># For each ring that is a candidate, select all of the reference and targets from the p matrix</span>
                    <span class="c1"># the first part of the slice grabs all candidate points and the second half in the first two args</span>
                    <span class="c1"># selects the ref and target (respectively).</span>
                    <span class="n">npoints_in_ring</span> <span class="o">=</span> <span class="n">points_num</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">ref_points</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:</span><span class="n">npoints_in_ring</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">j</span><span class="p">:</span><span class="mi">4</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># Slice out the reference coords</span>
                    <span class="n">tar_points</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:</span><span class="n">npoints_in_ring</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>  <span class="c1"># Slice out the target coords</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">p_idx</span><span class="p">[:</span><span class="n">npoints_in_ring</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># slice out the indices</span>

                    <span class="n">xref</span><span class="p">,</span> <span class="n">xtar</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">ransac_permute</span><span class="p">(</span><span class="n">ref_points</span><span class="p">,</span> <span class="n">tar_points</span><span class="p">,</span> <span class="n">tolerance_val</span><span class="p">,</span> <span class="n">target_points</span><span class="p">)</span>
                    <span class="c1"># This selects the best of the rings</span>
                    <span class="n">max_cons</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_cons</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xref</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xref</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">target_points</span><span class="p">:</span>
                        <span class="c1"># Solution found</span>
                        <span class="c1"># Instead of returning the ref and tar points, return the ids</span>
                        <span class="n">ring</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">ring_radius</span><span class="p">,</span> <span class="n">j</span><span class="o">*</span><span class="n">ring_radius</span><span class="o">+</span><span class="n">ring_radius</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">xref</span><span class="p">,</span> <span class="n">xtar</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">ring</span>
        <span class="c1"># Mask the reference point and iterate to the next randomly selected point</span>
        <span class="n">ref_mask</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">metr</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Exhausted&#39;</span></div>

<div class="viewcode-block" id="points_in_ring"><a class="viewcode-back" href="../../../library/matcher/cpu_ring_matcher.html#autocnet.matcher.cpu_ring_matcher.points_in_ring">[docs]</a><span class="k">def</span> <span class="nf">points_in_ring</span><span class="p">(</span><span class="n">distance_vector</span><span class="p">,</span> <span class="n">inner_radius</span><span class="p">,</span> <span class="n">outer_radius</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the indices of all points within a given distance from</span>
<span class="sd">    a distance vector. The vector is assumed to be 1d.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    distance_vector : ndarray</span>
<span class="sd">                      (n,1) array of distances between a point and a set of points</span>
<span class="sd">    inner_radius : float</span>
<span class="sd">                   The lower threshold for the ring</span>
<span class="sd">    outer_radius : float</span>
<span class="sd">                   The outer threshold for the ring</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       (n,1) array of booleans where all correspondences inside of the array are True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">distance_vector</span> <span class="o">&gt;=</span> <span class="n">inner_radius</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">distance_vector</span> <span class="o">&lt;=</span> <span class="n">outer_radius</span><span class="p">)</span></div>

<div class="viewcode-block" id="dynamically_grow_array"><a class="viewcode-back" href="../../../library/matcher/cpu_ring_matcher.html#autocnet.matcher.cpu_ring_matcher.dynamically_grow_array">[docs]</a><span class="k">def</span> <span class="nf">dynamically_grow_array</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an array, dynamically grow the array vertically with an m,n array of zeros</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : ndarray</span>
<span class="sd">            The array to be grown</span>
<span class="sd">    m : int</span>
<span class="sd">        The number of new rows to add</span>

<span class="sd">    dtype : obj</span>
<span class="sd">            A numpy data type that is used for the new entries. A </span>
<span class="sd">            dynamically grown array will upcast to the most complex</span>
<span class="sd">            data type.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array : ndarray</span>
<span class="sd">            The expanded array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">array_append</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">array</span><span class="p">,</span> <span class="n">array_append</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">array</span></div>


<div class="viewcode-block" id="directed_ring_match"><a class="viewcode-back" href="../../../library/matcher/cpu_ring_matcher.html#autocnet.matcher.cpu_ring_matcher.directed_ring_match">[docs]</a><span class="k">def</span> <span class="nf">directed_ring_match</span><span class="p">(</span><span class="n">ref_feats</span><span class="p">,</span> <span class="n">tar_feats</span><span class="p">,</span> <span class="n">ref_desc</span><span class="p">,</span> <span class="n">tar_desc</span><span class="p">,</span> <span class="n">ring_min</span><span class="p">,</span> <span class="n">ring_max</span><span class="p">,</span> <span class="n">target_points</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">tolerance_value</span><span class="o">=</span><span class="mf">0.02</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an input set of reference features and target features, attempt to find</span>
<span class="sd">    correspondences within a given ring, where the ring is defined by min and max</span>
<span class="sd">    radii.  This is a directed version of the ring_match function, in that this</span>
<span class="sd">    function assumes that the correspondence is within the defined ring.</span>

<span class="sd">    This implementation is inspired by and uses the ring_match implementation above, developed</span>
<span class="sd">    by Sidiropoulos and Muller.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ref_feats : np.ndarray</span>
<span class="sd">                where the first 2 columns are the x,y coordinates in pixel space,</span>
<span class="sd">                columns 3 &amp; 4 are the x,y coordinates in m or km in the same</span>
<span class="sd">                reference as the target features</span>

<span class="sd">    tar_feats : np.ndarray</span>
<span class="sd">                where the first 2 columns are the x,y coordinates in pixel space,</span>
<span class="sd">                columns 3 &amp; 4 are the x,y coordinates in m or km in the same</span>
<span class="sd">                reference as the reference features</span>

<span class="sd">    ref_desc : np.ndarray</span>
<span class="sd">               (m, n) where m are the individual SIFT features and</span>
<span class="sd">               n are the descriptor length (usually 128)</span>

<span class="sd">    tar_desc : np.ndarray</span>
<span class="sd">               (m, n) where m are the individual SIFT features and</span>
<span class="sd">               n are the descriptor length (usually 128)</span>

<span class="sd">    ring_min : numeric</span>
<span class="sd">               The inner distance of the ring</span>

<span class="sd">    ring_max : numeric</span>
<span class="sd">               The outer distance of the ring</span>


<span class="sd">    target_points : int</span>
<span class="sd">                    The number of points that constitute a valid match</span>

<span class="sd">    tolerance : float</span>
<span class="sd">                The tolerance for outlier detection in point ordering between estimated</span>
<span class="sd">                resolutions</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xref : ndarray</span>
<span class="sd">           (n,4) array of the correspondences selected from the ref_feats input</span>

<span class="sd">    xtar : ndarray</span>
<span class="sd">           (n,4) array of the correspondences selected from the tar_feats input</span>

<span class="sd">    p_idx : ndarray</span>
<span class="sd">            (n,2) array of the indices in the ref_feats and tar_feats input arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Reference and target features</span>
    <span class="n">ref_xy</span> <span class="o">=</span> <span class="n">ref_feats</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">ref_xmym</span> <span class="o">=</span> <span class="n">ref_feats</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:]</span>
    <span class="n">tar_xy</span> <span class="o">=</span> <span class="n">tar_feats</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">tar_xmym</span> <span class="o">=</span> <span class="n">tar_feats</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:]</span>

    <span class="n">numr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_feats</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numr</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="n">p_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numr</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
    <span class="n">points_num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Iterate over all of the reference points seeking a match</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numr</span><span class="p">):</span>
        <span class="n">current_ref_desc</span> <span class="o">=</span> <span class="n">ref_desc</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
        <span class="n">current_ref_xy</span> <span class="o">=</span> <span class="n">ref_xy</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
        <span class="n">current_ref_xmym</span> <span class="o">=</span> <span class="n">ref_xmym</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>

        <span class="c1"># Compute the euclidean distance between the reference point and all targets</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">current_ref_xmym</span> <span class="o">-</span> <span class="n">tar_xmym</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Find all of the candidates, if none, skip</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="n">ring_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">ring_max</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">current_tar_descs</span> <span class="o">=</span> <span class="n">tar_desc</span><span class="p">[</span><span class="n">z</span><span class="p">]</span>
        <span class="n">current_tar_xys</span> <span class="o">=</span> <span class="n">tar_xy</span><span class="p">[</span><span class="n">z</span><span class="p">]</span>
        <span class="n">z_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">sift_match</span><span class="p">(</span><span class="n">current_ref_desc</span><span class="p">,</span> <span class="n">current_tar_descs</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p</span><span class="p">[</span><span class="n">points_num</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_ref_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">current_ref_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">current_tar_xys</span><span class="p">[</span><span class="n">match</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">current_tar_xys</span><span class="p">[</span><span class="n">match</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
            <span class="c1"># Set the id of the point</span>
            <span class="n">p_idx</span><span class="p">[</span><span class="n">points_num</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">z_idx</span><span class="p">[</span><span class="n">match</span><span class="p">]]</span>
            <span class="n">points_num</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">points_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># No candidate matches found in this set.</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="c1"># Now that the candidates have all been located, check their geometric relationships to find the good matches</span>
    <span class="n">ref_points</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:</span><span class="n">points_num</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">tar_points</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:</span><span class="n">points_num</span><span class="p">,</span> <span class="mi">2</span><span class="p">:]</span>
    <span class="n">xref</span><span class="p">,</span> <span class="n">xtar</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">ransac_permute</span><span class="p">(</span><span class="n">ref_points</span><span class="p">,</span> <span class="n">tar_points</span><span class="p">,</span> <span class="n">tolerance_value</span><span class="p">,</span> <span class="n">target_points</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xref</span><span class="p">,</span> <span class="n">xtar</span><span class="p">,</span> <span class="n">p_idx</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>

<div class="viewcode-block" id="ring_match_one"><a class="viewcode-back" href="../../../library/matcher/cpu_ring_matcher.html#autocnet.matcher.cpu_ring_matcher.ring_match_one">[docs]</a><span class="k">def</span> <span class="nf">ring_match_one</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ref_feats</span><span class="p">,</span> <span class="n">tar_feats</span><span class="p">,</span> <span class="n">ref_desc</span><span class="p">,</span> <span class="n">tar_desc</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">search_radius</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">max_search_radius</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">target_points</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an x,y coordinate where a match is desired, find all candidates within</span>
<span class="sd">    some search radius and attempt to generate a match.  If no matches are identified</span>
<span class="sd">    expand the search radius by search_radius and search again. Once a match</span>
<span class="sd">    is identified (by calling the directed matcher and finding a geometric consensus</span>
<span class="sd">    with at least target_points), the match closest to the given x,y is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : int</span>
<span class="sd">        x coordinate in image space</span>

<span class="sd">    y : int</span>
<span class="sd">        y coordinate in image space</span>

<span class="sd">    ref_feats : np.ndarray</span>
<span class="sd">                where the first 2 columns are the x,y coordinates in pixel space,</span>
<span class="sd">                columns 3 &amp; 4 are the x,y coordinates in m or km in the same</span>
<span class="sd">                reference as the target features</span>

<span class="sd">    tar_feats : np.ndarray</span>
<span class="sd">                where the first 2 columns are the x,y coordinates in pixel space,</span>
<span class="sd">                columns 3 &amp; 4 are the x,y coordinates in m or km in the same</span>
<span class="sd">                reference as the reference features</span>

<span class="sd">    ref_desc : np.ndarray</span>
<span class="sd">               (m, n) where m are the individual SIFT features and</span>
<span class="sd">               n are the descriptor length (usually 128)</span>

<span class="sd">    tar_desc : np.ndarray</span>
<span class="sd">               (m, n) where m are the individual SIFT features and</span>
<span class="sd">               n are the descriptor length (usually 128)</span>

<span class="sd">    ring : tuple</span>
<span class="sd">           in the form (min_ring, max_ring)</span>

<span class="sd">    search_radius : numeric</span>
<span class="sd">                    The radius of the search extent in image pixels</span>

<span class="sd">    target_points : int</span>
<span class="sd">                    The desired number of points to identify a correspondence</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">search</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Start search within search_radius of the center of the cell</span>
    <span class="k">while</span> <span class="n">search_radius</span> <span class="o">&lt;=</span> <span class="n">max_search_radius</span><span class="p">:</span>
        <span class="c1"># Find all correspondences within 100m of the center of the cell to fill</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ref_feats</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">search_radius</span><span class="p">)</span> <span class="o">&amp;</span>\
                              <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ref_feats</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">search_radius</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">sref_feats</span> <span class="o">=</span> <span class="n">ref_feats</span><span class="p">[</span><span class="n">candidates</span><span class="p">]</span>
        <span class="n">sref_desc</span> <span class="o">=</span> <span class="n">ref_desc</span><span class="p">[</span><span class="n">candidates</span><span class="p">]</span>

        <span class="n">min_ring</span> <span class="o">=</span> <span class="n">ring</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">max_ring</span> <span class="o">=</span> <span class="n">ring</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">sx_ref</span><span class="p">,</span> <span class="n">sx_tar</span><span class="p">,</span> <span class="n">sindices</span><span class="p">,</span> <span class="o">=</span> <span class="n">directed_ring_match</span><span class="p">(</span><span class="n">sref_feats</span><span class="p">,</span> <span class="n">tar_feats</span><span class="p">,</span> <span class="n">sref_desc</span><span class="p">,</span> <span class="n">tar_desc</span><span class="p">,</span> <span class="n">min_ring</span><span class="p">,</span> <span class="n">max_ring</span><span class="p">,</span> <span class="n">target_points</span><span class="o">=</span><span class="n">target_points</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sindices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">target_points</span><span class="p">:</span>

            <span class="c1">#sindices[:,0] = candidates[sindices[:,0]]</span>

            <span class="c1"># Find the match that is closest to the center of the cell.</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
            <span class="n">ref_coords</span> <span class="o">=</span> <span class="n">sref_feats</span><span class="p">[</span><span class="n">sindices</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">ref_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">closest_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

            <span class="c1"># Remap the reference from the subset to the full set</span>
            <span class="n">sindices</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[</span><span class="n">sindices</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span>

            <span class="k">return</span> <span class="n">sindices</span><span class="p">[</span><span class="n">closest_idx</span><span class="p">]</span>

        <span class="c1"># expand the search radius by 100m</span>
        <span class="n">search_radius</span> <span class="o">+=</span> <span class="n">search_radius</span>
        <span class="k">if</span> <span class="n">search_radius</span> <span class="o">&gt;=</span> <span class="n">max_search_radius</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="add_correspondences"><a class="viewcode-back" href="../../../library/matcher/cpu_ring_matcher.html#autocnet.matcher.cpu_ring_matcher.add_correspondences">[docs]</a><span class="k">def</span> <span class="nf">add_correspondences</span><span class="p">(</span><span class="n">in_feats</span><span class="p">,</span> <span class="n">ref_feats</span><span class="p">,</span> <span class="n">tar_feats</span><span class="p">,</span> <span class="n">ref_desc</span><span class="p">,</span> <span class="n">tar_desc</span><span class="p">,</span>  <span class="n">xextent</span><span class="p">,</span> <span class="n">yextent</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">n_x_cells</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n_y_cells</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">target_points</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a set of input features and x/y extents lay a regular grid over the area</span>
<span class="sd">    defined by the extents and find correspondences within each grid cell that</span>
<span class="sd">    does not have any existing correspondences.</span>

<span class="sd">    Then number of cells are defined by the n_x/y_cells parameters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in_feats : ndarray</span>
<span class="sd">               (n,m) input features with the first column being x-coordinate</span>
<span class="sd">               in image space and the second column being y-coordinate.</span>

<span class="sd">    ref_feats : np.ndarray</span>
<span class="sd">                where the first 2 columns are the x,y coordinates in pixel space,</span>
<span class="sd">                columns 3 &amp; 4 are the x,y coordinates in m or km in the same</span>
<span class="sd">                reference as the target features</span>

<span class="sd">    tar_feats : np.ndarray</span>
<span class="sd">                where the first 2 columns are the x,y coordinates in pixel space,</span>
<span class="sd">                columns 3 &amp; 4 are the x,y coordinates in m or km in the same</span>
<span class="sd">                reference as the reference features</span>

<span class="sd">    ref_desc : np.ndarray</span>
<span class="sd">               (m, n) where m are the individual SIFT features and</span>
<span class="sd">               n are the descriptor length (usually 128)</span>

<span class="sd">    tar_desc : np.ndarray</span>
<span class="sd">               (m, n) where m are the individual SIFT features and</span>
<span class="sd">               n are the descriptor length (usually 128)</span>

<span class="sd">    xextent : tuple</span>
<span class="sd">              in the form (minx, maxx)</span>

<span class="sd">    yextent : tuple</span>
<span class="sd">              in the form (miny, maxy)</span>

<span class="sd">    ring : tuple</span>
<span class="sd">           in the form (min_ring, max_ring)</span>

<span class="sd">    n_x_cells : int</span>
<span class="sd">                the number of cells to generate in the x direction</span>

<span class="sd">    n_y_cells : int</span>
<span class="sd">                the number of cells to generate in the y direction</span>

<span class="sd">    target_points : int</span>
<span class="sd">                    The desired number of points to identify a correspondence</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xextent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xextent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_x_cells</span><span class="p">)</span>
    <span class="n">y_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">yextent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yextent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_y_cells</span><span class="p">)</span>

    <span class="c1"># Find the cells that are populated and assign as covered</span>
    <span class="n">xbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">in_feats</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">x_edges</span><span class="p">)</span>
    <span class="n">ybins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">in_feats</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">y_edges</span><span class="p">)</span>
    <span class="n">covered</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xbins</span><span class="p">,</span> <span class="n">ybins</span><span class="p">))</span>

    <span class="n">refs_to_add</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Loop over all cells</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_x_cells</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_y_cells</span><span class="p">):</span>
            <span class="c1"># and process only the uncovered cells</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">covered</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">x_cell_center</span> <span class="o">=</span> <span class="n">x_edges</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_edges</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">y_cell_center</span> <span class="o">=</span> <span class="n">y_edges</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">y_edges</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_edges</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>

            <span class="n">ref</span> <span class="o">=</span> <span class="n">ring_match_one</span><span class="p">(</span><span class="n">x_cell_center</span><span class="p">,</span> <span class="n">y_cell_center</span><span class="p">,</span> <span class="n">ref_feats</span><span class="p">,</span> <span class="n">tar_feats</span><span class="p">,</span> <span class="n">ref_desc</span><span class="p">,</span> <span class="n">tar_desc</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">refs_to_add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">refs_to_add</span></div>
</pre></div>

          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2017 - , AutoCNetDevelopers.
      </li>
      <li>
      Last updated on Jul 27, 2020.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 3.1.2.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>