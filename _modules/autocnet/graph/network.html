<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>autocnet.graph.network &mdash; AutoCNet</title>
    
    <link rel="stylesheet" type="text/css" href="../../../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../../../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../../../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     'Please install this project with setup.py',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../None"></script>
    <script type="text/javascript" src="../../../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" >
    <link rel="search" title="Search" href="../../../search.html" >
    <link rel="top" title="AutoCNet" href="../../../index.html" >
    <link rel="up" title="Module code" href="../../index.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="../../../index.html">AutoCNet</a></li>
	
          <li class="active"><a href="../../index.html" accesskey="U">Module code</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../../../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../../../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">

        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <h1>Source code for autocnet.graph.network</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">shutil</span> <span class="kn">import</span> <span class="n">copyfile</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">gmtime</span><span class="p">,</span> <span class="n">strftime</span><span class="p">,</span> <span class="n">time</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">StrictRedis</span>
<span class="kn">import</span> <span class="nn">shapely</span>

<span class="kn">import</span> <span class="nn">geoalchemy2</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative.api</span> <span class="kn">import</span> <span class="n">DeclarativeMeta</span>
<span class="kn">import</span> <span class="nn">shapely.affinity</span>
<span class="kn">import</span> <span class="nn">shapely.geometry</span>
<span class="kn">import</span> <span class="nn">shapely.wkt</span> <span class="k">as</span> <span class="nn">swkt</span>
<span class="kn">import</span> <span class="nn">shapely.ops</span>

<span class="kn">from</span> <span class="nn">plio.io.io_controlnetwork</span> <span class="kn">import</span> <span class="n">to_isis</span><span class="p">,</span> <span class="n">from_isis</span>
<span class="kn">from</span> <span class="nn">plio.io</span> <span class="kn">import</span> <span class="n">io_hdf</span><span class="p">,</span> <span class="n">io_json</span>
<span class="kn">from</span> <span class="nn">plio.utils</span> <span class="kn">import</span> <span class="n">utils</span> <span class="k">as</span> <span class="n">io_utils</span>
<span class="kn">from</span> <span class="nn">plio.io.io_gdal</span> <span class="kn">import</span> <span class="n">GeoDataset</span>
<span class="kn">from</span> <span class="nn">plio.io.isis_serial_number</span> <span class="kn">import</span> <span class="n">generate_serial_number</span>
<span class="kn">from</span> <span class="nn">plio.io</span> <span class="kn">import</span> <span class="n">io_controlnetwork</span> <span class="k">as</span> <span class="n">cnet</span>


<span class="kn">from</span> <span class="nn">plurmy</span> <span class="kn">import</span> <span class="n">Slurm</span>

<span class="kn">import</span> <span class="nn">autocnet</span>
<span class="kn">from</span> <span class="nn">autocnet.config_parser</span> <span class="kn">import</span> <span class="n">parse_config</span>
<span class="kn">from</span> <span class="nn">autocnet.cg</span> <span class="kn">import</span> <span class="n">cg</span>
<span class="kn">from</span> <span class="nn">autocnet.graph</span> <span class="kn">import</span> <span class="n">markov_cluster</span>
<span class="kn">from</span> <span class="nn">autocnet.graph.edge</span> <span class="kn">import</span> <span class="n">Edge</span><span class="p">,</span> <span class="n">NetworkEdge</span>
<span class="kn">from</span> <span class="nn">autocnet.graph.node</span> <span class="kn">import</span> <span class="n">Node</span><span class="p">,</span> <span class="n">NetworkNode</span>
<span class="kn">from</span> <span class="nn">autocnet.io</span> <span class="kn">import</span> <span class="n">network</span> <span class="k">as</span> <span class="n">io_network</span>
<span class="kn">from</span> <span class="nn">autocnet.io.db</span> <span class="kn">import</span> <span class="n">controlnetwork</span> <span class="k">as</span> <span class="n">io_controlnetwork</span>
<span class="kn">from</span> <span class="nn">autocnet.io.db.model</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Images</span><span class="p">,</span> <span class="n">Keypoints</span><span class="p">,</span> <span class="n">Matches</span><span class="p">,</span> <span class="n">Cameras</span><span class="p">,</span> <span class="n">Points</span><span class="p">,</span>
                                  <span class="n">Base</span><span class="p">,</span> <span class="n">Overlay</span><span class="p">,</span> <span class="n">Edges</span><span class="p">,</span> <span class="n">Costs</span><span class="p">,</span> <span class="n">Measures</span><span class="p">,</span> <span class="n">JsonEncoder</span><span class="p">,</span>
                                  <span class="n">try_db_creation</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">autocnet.io.db.connection</span> <span class="kn">import</span> <span class="n">new_connection</span><span class="p">,</span> <span class="n">Parent</span>
<span class="kn">from</span> <span class="nn">autocnet.matcher</span> <span class="kn">import</span> <span class="n">subpixel</span>
<span class="kn">from</span> <span class="nn">autocnet.matcher</span> <span class="kn">import</span> <span class="n">cross_instrument_matcher</span> <span class="k">as</span> <span class="n">cim</span>
<span class="kn">from</span> <span class="nn">autocnet.vis.graph_view</span> <span class="kn">import</span> <span class="n">plot_graph</span><span class="p">,</span> <span class="n">cluster_plot</span>
<span class="kn">from</span> <span class="nn">autocnet.control</span> <span class="kn">import</span> <span class="n">control</span>
<span class="kn">from</span> <span class="nn">autocnet.spatial.overlap</span> <span class="kn">import</span> <span class="n">compute_overlaps_sql</span>
<span class="kn">from</span> <span class="nn">autocnet.spatial.isis</span> <span class="kn">import</span> <span class="n">point_info</span>
<span class="kn">from</span> <span class="nn">autocnet.transformation.spatial</span> <span class="kn">import</span> <span class="n">reproject</span><span class="p">,</span> <span class="n">og2oc</span>

<span class="c1">#np.warnings.filterwarnings(&#39;ignore&#39;)</span>

<span class="c1"># The total number of pixels squared that can fit into the keys number of GB of RAM for SIFT.</span>
<span class="n">MAXSIZE</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
           <span class="mi">2</span><span class="p">:</span> <span class="mi">6250</span><span class="p">,</span>
           <span class="mi">4</span><span class="p">:</span> <span class="mi">8840</span><span class="p">,</span>
           <span class="mi">8</span><span class="p">:</span> <span class="mi">12500</span><span class="p">,</span>
           <span class="mi">12</span><span class="p">:</span> <span class="mi">15310</span><span class="p">}</span>


<div class="viewcode-block" id="CandidateGraph"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph">[docs]</a><span class="k">class</span> <span class="nc">CandidateGraph</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A NetworkX derived directed graph to store candidate overlap images.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    node_counter : int</span>
<span class="sd">                   The number of nodes in the graph.</span>
<span class="sd">    node_name_map : dict</span>
<span class="sd">                    The mapping of image labels (i.e. file base names) to their</span>
<span class="sd">                    corresponding node indices</span>

<span class="sd">    clusters : dict</span>
<span class="sd">               of clusters with key as the cluster id and value as a</span>
<span class="sd">               list of node indices</span>

<span class="sd">    cn : object</span>
<span class="sd">         A control network object instantiated by calling generate_cnet.</span>
<span class="sd">    ----------</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">node_factory</span> <span class="o">=</span> <span class="n">Node</span>
    <span class="n">edge_factory</span> <span class="o">=</span> <span class="n">Edge</span>
    <span class="n">measures_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;point_id&#39;</span><span class="p">,</span> <span class="s1">&#39;image_index&#39;</span><span class="p">,</span> <span class="s1">&#39;keypoint_index&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;edge&#39;</span><span class="p">,</span> <span class="s1">&#39;match_idx&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;x_off&#39;</span><span class="p">,</span> <span class="s1">&#39;y_off&#39;</span><span class="p">,</span> <span class="s1">&#39;corr&#39;</span><span class="p">]</span>
    <span class="c1"># dtypes are usful for allowing merges, otherwise they default to object</span>
    <span class="n">cnet_dtypes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;match_idx&#39;</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="s1">&#39;point_id&#39;</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="s1">&#39;image_index&#39;</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="s1">&#39;keypoint_index&#39;</span> <span class="p">:</span> <span class="nb">int</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">basepath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node_id_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlaps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CandidateGraph</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;creationdate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">gmtime</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;modifieddate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">gmtime</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;node_name_map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;node_counter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_point_id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_measure_id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">measure_to_point</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">controlnetwork</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">measures_keys</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cnet_dtypes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">basepath</span><span class="p">:</span>
                <span class="n">image_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">basepath</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">image_path</span> <span class="o">=</span> <span class="n">i</span>

            <span class="k">if</span> <span class="n">node_id_map</span><span class="p">:</span>
                <span class="n">node_id</span> <span class="o">=</span> <span class="n">node_id_map</span><span class="p">[</span><span class="n">image_path</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;node_counter&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;node_counter&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">n</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_factory</span><span class="p">(</span>
                <span class="n">image_name</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">image_path</span><span class="o">=</span><span class="n">image_path</span><span class="p">,</span> <span class="n">node_id</span><span class="o">=</span><span class="n">node_id</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;node_name_map&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_id</span>

        <span class="c1"># Relabel the nodes in place to use integer node ids</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;node_name_map&#39;</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">s</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">s</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_factory</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>
            <span class="c1"># Unidrected graph - both representation point at the same data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">s</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>

        <span class="k">if</span> <span class="n">overlaps</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_overlaps</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: This needs to be a real self identifying key</span>
        <span class="k">return</span> <span class="s1">&#39;abcde&#39;</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__key</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Check the nodes</span>
        <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">nodes</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">edges</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">s</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">s</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">edges</span><span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)][</span><span class="s1">&#39;data&#39;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_order_adjacency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">maxsize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_maxsize&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maxsize</span> <span class="o">=</span> <span class="n">MAXSIZE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxsize</span>

    <span class="nd">@maxsize</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">maxsize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">MAXSIZE</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Value must be in </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">MAXSIZE</span><span class="o">.</span><span class="n">keys</span><span class="p">()))))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maxsize</span> <span class="o">=</span> <span class="n">MAXSIZE</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unmatched_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of edges (source, destination) that do not have</span>
<span class="sd">        entries in the matches dataframe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unmatched</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">unmatched</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">s</span><span class="p">,</span><span class="n">d</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">unmatched</span>

<div class="viewcode-block" id="CandidateGraph.from_filelist"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.from_filelist">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_filelist</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filelist</span><span class="p">,</span> <span class="n">basepath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiate the class using a filelist as a python list.</span>
<span class="sd">        An adjacency structure is calculated using the lat/lon information in the</span>
<span class="sd">        input images. Currently only images with this information are supported.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filelist : list</span>
<span class="sd">                   A list containing the files (with full paths) to construct an adjacency graph from</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : object</span>
<span class="sd">          A Network graph object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filelist</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">filelist</span> <span class="o">=</span> <span class="n">io_utils</span><span class="o">.</span><span class="n">file_to_list</span><span class="p">(</span><span class="n">filelist</span><span class="p">)</span>
        <span class="c1"># TODO: Reject unsupported file formats + work with more file formats</span>
        <span class="k">if</span> <span class="n">basepath</span><span class="p">:</span>
            <span class="n">datasets</span> <span class="o">=</span> <span class="p">[</span><span class="n">GeoDataset</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">basepath</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">filelist</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">datasets</span> <span class="o">=</span> <span class="p">[</span><span class="n">GeoDataset</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">filelist</span><span class="p">]</span>

        <span class="c1"># This is brute force for now, could swap to an RTree at some point.</span>
        <span class="n">adjacency_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">valid_datasets</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
            <span class="n">adjacency_dict</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">file_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">fp</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">footprint</span>
            <span class="k">if</span> <span class="n">fp</span> <span class="ow">and</span> <span class="n">fp</span><span class="o">.</span><span class="n">IsValid</span><span class="p">():</span>
                <span class="n">valid_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s1">&#39;Missing or invalid geospatial data for </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">base_name</span><span class="p">))</span>

        <span class="c1"># Grab the footprints and test for intersection</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">valid_datasets</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">i_fp</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">footprint</span>
            <span class="n">j_fp</span> <span class="o">=</span> <span class="n">j</span><span class="o">.</span><span class="n">footprint</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i_fp</span><span class="o">.</span><span class="n">Intersects</span><span class="p">(</span><span class="n">j_fp</span><span class="p">):</span>
                    <span class="n">adjacency_dict</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">file_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">file_name</span><span class="p">)</span>
                    <span class="n">adjacency_dict</span><span class="p">[</span><span class="n">j</span><span class="o">.</span><span class="n">file_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">file_name</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s1">&#39;Failed to calculate intersection between </span><span class="si">{}</span><span class="s1"> and </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_adjacency</span><span class="p">(</span><span class="n">adjacency_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.from_adjacency"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.from_adjacency">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_adjacency</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">input_adjacency</span><span class="p">,</span> <span class="n">node_id_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basepath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiate the class using an adjacency dict or file. The input must contain relative or</span>
<span class="sd">        absolute paths to image files.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input_adjacency : dict or str</span>
<span class="sd">                          An adjacency dictionary or the name of a file containing an adjacency dictionary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">         : object</span>
<span class="sd">           A Network graph object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from autocnet.examples import get_path</span>
<span class="sd">        &gt;&gt;&gt; inputfile = get_path(&#39;adjacency.json&#39;)</span>
<span class="sd">        &gt;&gt;&gt; candidate_graph = CandidateGraph.from_adjacency(inputfile)</span>
<span class="sd">        &gt;&gt;&gt; sorted(candidate_graph.nodes())</span>
<span class="sd">        [0, 1, 2, 3, 4, 5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_adjacency</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">input_adjacency</span> <span class="o">=</span> <span class="n">io_json</span><span class="o">.</span><span class="n">read_json</span><span class="p">(</span><span class="n">input_adjacency</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">input_adjacency</span><span class="p">,</span> <span class="n">basepath</span><span class="o">=</span><span class="n">basepath</span><span class="p">,</span> <span class="n">node_id_map</span><span class="o">=</span><span class="n">node_id_map</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_save</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">input_file</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">io_network</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">input_file</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_date</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the last modified date attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;modifieddate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">,</span> <span class="n">gmtime</span><span class="p">())</span>

<div class="viewcode-block" id="CandidateGraph.get_name"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.get_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the image name for the given node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_index : int</span>
<span class="sd">                     The index of the node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">         : str</span>
<span class="sd">           The name of the image attached to the given node.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;image_name&#39;</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">get_matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clean_keys</span><span class="o">=</span><span class="p">[]):</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">match</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">clean</span><span class="p">(</span><span class="n">clean_keys</span><span class="o">=</span><span class="n">clean_keys</span><span class="p">)</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">match</span><span class="p">[[</span><span class="s1">&#39;source_image&#39;</span><span class="p">,</span> <span class="s1">&#39;source_idx&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;destination_image&#39;</span><span class="p">,</span> <span class="s1">&#39;destination_idx&#39;</span><span class="p">]]</span>
            <span class="n">skps</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">get_keypoints</span><span class="p">(</span><span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">match</span><span class="o">.</span><span class="n">source_idx</span><span class="p">)</span>
            <span class="n">skps</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;source_x&#39;</span><span class="p">,</span> <span class="s1">&#39;source_y&#39;</span><span class="p">]</span>
            <span class="n">dkps</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">get_keypoints</span><span class="p">(</span><span class="s1">&#39;destination&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">match</span><span class="o">.</span><span class="n">destination_idx</span><span class="p">)</span>
            <span class="n">dkps</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;destination_x&#39;</span><span class="p">,</span> <span class="s1">&#39;destination_y&#39;</span><span class="p">]</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">skps</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;source_idx&#39;</span><span class="p">)</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dkps</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;destination_idx&#39;</span><span class="p">)</span>

            <span class="c1"># TODO: This is a bandaid fix, join is creating an insane amount of duplicate points</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
            <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">matches</span>

<div class="viewcode-block" id="CandidateGraph.add_node"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.add_node">[docs]</a>    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an image node to the graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image_name : str</span>
<span class="sd">                     The file name of the node</span>

<span class="sd">        adjacency : str list</span>
<span class="sd">                    List of files names of adjacent images that correspond</span>
<span class="sd">                    to names in CandidateGraph.graph[&quot;node_name_map&quot;]</span>
<span class="sd">        basepath : str</span>
<span class="sd">                    The base path to the node image file</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">image_name</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;image_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;adjacency&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># If image name is provided, build the node from the image before</span>
        <span class="c1"># calling nx.add_node()</span>
        <span class="k">if</span> <span class="n">image_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;basepath&quot;</span> <span class="ow">in</span> <span class="n">attr</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">image_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;basepath&quot;</span><span class="p">),</span> <span class="n">image_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">image_path</span> <span class="o">=</span> <span class="n">image_name</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">image_path</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot find </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">image_path</span><span class="p">))</span>
                <span class="k">return</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;node_counter&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;node_counter&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">image_name</span><span class="o">=</span><span class="n">image_name</span><span class="p">,</span>
                            <span class="n">image_path</span><span class="o">=</span><span class="n">image_path</span><span class="p">,</span>
                            <span class="n">node_id</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;node_name_map&quot;</span><span class="p">][</span><span class="n">new_node</span><span class="p">[</span><span class="s2">&quot;image_name&quot;</span><span class="p">]</span>
                                        <span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">[</span><span class="s2">&quot;node_id&quot;</span><span class="p">]</span>
            <span class="n">attr</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span>

        <span class="c1"># Add the new node to the graph using networkx</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CandidateGraph</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span>

        <span class="c1"># Populate adjacency, if provided</span>
        <span class="k">if</span> <span class="n">new_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">adj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">adj_img</span> <span class="ow">in</span> <span class="n">adj</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">adj_img</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;node_name_map&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> not found in the graph&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">adj_img</span><span class="p">))</span>
                    <span class="k">continue</span>
                <span class="n">new_idx</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">[</span><span class="s2">&quot;node_id&quot;</span><span class="p">]</span>
                <span class="n">adj_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;node_name_map&quot;</span><span class="p">][</span><span class="n">adj_img</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">adj_img</span><span class="p">,</span> <span class="n">new_node</span><span class="p">[</span><span class="s2">&quot;image_name&quot;</span><span class="p">])</span></div>

<div class="viewcode-block" id="CandidateGraph.add_edge"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.add_edge">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an edge with the given src and dst nodes to the graph</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : str</span>
<span class="sd">            The filename of the source image for the edge</span>

<span class="sd">        v : Node</span>
<span class="sd">            The filename of the destination image for the edge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;node_name_map&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span>
            <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;node_name_map&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span>
                <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;node_name_map&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="c1"># Grab node ids &amp; create edge obj</span>
            <span class="n">s_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;node_name_map&quot;</span><span class="p">][</span><span class="n">u</span><span class="p">]</span>
            <span class="n">d_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;node_name_map&quot;</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">Edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">s_id</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">d_id</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
            <span class="c1"># Prepare data for networkx</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">s_id</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">d_id</span>
            <span class="n">attr</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_edge</span>
        <span class="c1"># Add the new edge to the graph using networkx</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CandidateGraph</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.extract_features"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.extract_features">[docs]</a>    <span class="k">def</span> <span class="nf">extract_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts features from each image in the graph and uses the result to assign the</span>
<span class="sd">        node attributes for &#39;handle&#39;, &#39;image&#39;, &#39;keypoints&#39;, and &#39;descriptors&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">):</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">read_array</span><span class="p">(</span><span class="n">band</span><span class="o">=</span><span class="n">band</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">extract_features</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span></div>

<div class="viewcode-block" id="CandidateGraph.extract_features_with_downsampling"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.extract_features_with_downsampling">[docs]</a>    <span class="k">def</span> <span class="nf">extract_features_with_downsampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">downsample_amount</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract interest points from a downsampled array.  The array is downsampled</span>
<span class="sd">        by the downsample_amount keyword using the Lanconz downsample amount.  If the</span>
<span class="sd">        downsample keyword is not supplied, compute a downsampling constant as the</span>
<span class="sd">        total array size divided by the network maxsize attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        downsample_amount : int</span>
<span class="sd">                            The amount of downsampling to apply to the image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">downsample_amount</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">total_size</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">raster_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> \
                    <span class="n">node</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">raster_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">downsample_amount</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">total_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">extract_features_with_downsampling</span><span class="p">(</span>
                <span class="n">downsample_amount</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.extract_features_with_tiling"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.extract_features_with_tiling">[docs]</a>    <span class="k">def</span> <span class="nf">extract_features_with_tiling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="c1">#pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">extract_features_with_tiling</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.save_features"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.save_features">[docs]</a>    <span class="k">def</span> <span class="nf">save_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the features (keypoints and descriptors) for the</span>
<span class="sd">        specified nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out_path : str</span>
<span class="sd">                   Location of the output file.  If the file exists,</span>
<span class="sd">                   features are appended.  Otherwise, the file is created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">save_features</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">out_path</span><span class="p">,),</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;node&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.load_features"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.load_features">[docs]</a>    <span class="k">def</span> <span class="nf">load_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_path</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="p">[],</span> <span class="n">nfeatures</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load features (keypoints and descriptors) for the</span>
<span class="sd">        specified nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_path : str</span>
<span class="sd">                  Location of the input file.</span>

<span class="sd">        nodes : list</span>
<span class="sd">                of nodes to load features for.  If empty, load features</span>
<span class="sd">                for all nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">load_features</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">in_path</span><span class="p">,</span> <span class="n">nfeatures</span><span class="p">),</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;node&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span><span class="o">.</span><span class="n">load_features</span><span class="p">(</span><span class="n">in_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.match"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.match">[docs]</a>    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For all connected edges in the graph, apply feature matching</span>

<span class="sd">        See Also</span>
<span class="sd">        ----------</span>
<span class="sd">        autocnet.graph.edge.Edge.match</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_func_to_edges</span><span class="p">(</span><span class="s1">&#39;match&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.decompose_and_match"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.decompose_and_match">[docs]</a>    <span class="k">def</span> <span class="nf">decompose_and_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For all edges in the graph, apply coupled decomposition followed by</span>
<span class="sd">        feature matching.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        autocnet.graph.edge.Edge.decompose_and_match</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_func_to_edges</span><span class="p">(</span><span class="s1">&#39;decompose_and_match&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.estimate_mbrs"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.estimate_mbrs">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_mbrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each edge, estimate the overlap and compute a minimum bounding</span>
<span class="sd">        rectangle (mbr) in pixel space.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        autocnet.graoh.edge.Edge.compute_mbr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_func_to_edges</span><span class="p">(</span><span class="s1">&#39;estimate_mbr&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.compute_clusters"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.compute_clusters">[docs]</a>    <span class="k">def</span> <span class="nf">compute_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">markov_cluster</span><span class="o">.</span><span class="n">mcl</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply some graph clustering algorithm to compute a subset of the global</span>
<span class="sd">        graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : object</span>
<span class="sd">               The clustering function to be applied.  Defaults to</span>
<span class="sd">               Markov Clustering Algorithm</span>

<span class="sd">        args : list</span>
<span class="sd">               of arguments to be passed through to the func</span>

<span class="sd">        kwargs : dict</span>
<span class="sd">                 of keyword arguments to be passed through to the func</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.compute_triangular_cycles"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.compute_triangular_cycles">[docs]</a>    <span class="k">def</span> <span class="nf">compute_triangular_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all cycles of length 3.  This is similar</span>
<span class="sd">         to cycle_basis (networkX), but returns all cycles.</span>
<span class="sd">         As opposed to all basis cycles.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cycles : list</span>
<span class="sd">                 A list of cycles in the form [(a,b,c), (c,d,e)],</span>
<span class="sd">                 where letters indicate node identifiers</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; g = CandidateGraph()</span>
<span class="sd">        &gt;&gt;&gt; g.add_edges_from([(0,1), (0,2), (1,2), (0,3), (1,3), (2,3)])</span>
<span class="sd">        &gt;&gt;&gt; sorted(g.compute_triangular_cycles())</span>
<span class="sd">        [(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="ow">and</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
                    <span class="n">cycles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">])))</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">cycles</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.minimum_spanning_tree"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.minimum_spanning_tree">[docs]</a>    <span class="k">def</span> <span class="nf">minimum_spanning_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the minimum spanning tree of the graph</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">         : DataFrame</span>
<span class="sd">           boolean mask for edges in the minimum spanning tree</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mst</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">minimum_spanning_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_edge_subgraph</span><span class="p">(</span><span class="n">mst</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span></div>

<div class="viewcode-block" id="CandidateGraph.apply_func_to_edges"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.apply_func_to_edges">[docs]</a>    <span class="k">def</span> <span class="nf">apply_func_to_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="p">[],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterates over edges using an optional mask and and applies the given function.</span>
<span class="sd">        If func is not an attribute of Edge, raises AttributeError</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function : obj</span>
<span class="sd">                   function to be called on every edge</span>

<span class="sd">        graph_mask_keys : list</span>
<span class="sd">                          of keys in graph_masks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">return_lis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
            <span class="n">function</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s1">&#39; is not an attribute of Edge&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">return_lis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">return_lis</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">return_lis</span></div>

<div class="viewcode-block" id="CandidateGraph.apply"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applys a function to every node or edge, returns collected return</span>
<span class="sd">        values. If applying a functions to nodes, then all ignored nodes</span>
<span class="sd">        will be skipped.</span>

<span class="sd">        TODO: Merge with apply_func_to_edges?</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function : callable</span>
<span class="sd">                   Function to apply to graph. Should accept (id, data).</span>

<span class="sd">        on : string</span>
<span class="sd">             Whether to use nodes or edges. default is &#39;edge&#39;.</span>

<span class="sd">        out : var</span>
<span class="sd">              Optionally put the output in a variable rather than returning it</span>

<span class="sd">        args : iterable</span>
<span class="sd">               Some iterable of positional arguments for function.</span>

<span class="sd">        kwargs : dict</span>
<span class="sd">                 keyword args to pass into function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;edge&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">,</span>
            <span class="s1">&#39;edges&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">,</span>
            <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">,</span>
            <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">,</span>
            <span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">,</span>
            <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_iter</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is not callable.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">function</span><span class="p">))</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># We just want to the object, not the indices, so slice appropriately</span>
        <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="n">on</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">on</span><span class="p">](</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="n">obj</span><span class="p">],</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="n">obj</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="CandidateGraph.symmetry_checks"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.symmetry_checks">[docs]</a>    <span class="k">def</span> <span class="nf">symmetry_checks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Apply a symmetry check to all edges in the graph</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_func_to_edges</span><span class="p">(</span><span class="s1">&#39;symmetry_check&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.ratio_checks"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.ratio_checks">[docs]</a>    <span class="k">def</span> <span class="nf">ratio_checks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Apply a ratio check to all edges in the graph</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        autocnet.matcher.cpu_outlier_detector.DistanceRatio.compute</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_func_to_edges</span><span class="p">(</span><span class="s1">&#39;ratio_check&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.compute_overlaps"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.compute_overlaps">[docs]</a>    <span class="k">def</span> <span class="nf">compute_overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Computes overlap MBRs for all edges</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_func_to_edges</span><span class="p">(</span><span class="s1">&#39;compute_overlap&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.overlap_checks"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.overlap_checks">[docs]</a>    <span class="k">def</span> <span class="nf">overlap_checks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Apply overlap check to all edges in the graph</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_func_to_edges</span><span class="p">(</span><span class="s1">&#39;overlap_check&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.compute_homographies"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.compute_homographies">[docs]</a>    <span class="k">def</span> <span class="nf">compute_homographies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Compute homographies for all edges using identical parameters</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        autocnet.graph.edge.Edge.compute_homography</span>
<span class="sd">        autocnet.matcher.cpu_outlier_detector.compute_homography</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_func_to_edges</span><span class="p">(</span><span class="s1">&#39;compute_homography&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.compute_fundamental_matrices"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.compute_fundamental_matrices">[docs]</a>    <span class="k">def</span> <span class="nf">compute_fundamental_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Compute fundmental matrices for all edges using identical parameters</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        autocnet.matcher.cpu_outlier_detector.compute_fundamental_matrix</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_func_to_edges</span><span class="p">(</span><span class="s1">&#39;compute_fundamental_matrix&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.subpixel_register"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.subpixel_register">[docs]</a>    <span class="k">def</span> <span class="nf">subpixel_register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Compute subpixel offsets for all edges using identical parameters</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        autocnet.graph.edge.Edge.subpixel_register</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_func_to_edges</span><span class="p">(</span><span class="s1">&#39;subpixel_register&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.suppress"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.suppress">[docs]</a>    <span class="k">def</span> <span class="nf">suppress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Apply a metric of point suppression to the graph</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        autocnet.matcher.cpu_outlier_detector.SpatialSuppression</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_func_to_edges</span><span class="p">(</span><span class="s1">&#39;suppress&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.overlap"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.overlap">[docs]</a>    <span class="k">def</span> <span class="nf">overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Compute the percentage and area coverage of two images</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        autocnet.cg.cg.two_image_overlap</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_func_to_edges</span><span class="p">(</span><span class="s1">&#39;overlap&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.to_filelist"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.to_filelist">[docs]</a>    <span class="k">def</span> <span class="nf">to_filelist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a file list for the entire graph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        filelist : list</span>
<span class="sd">                   A list where each entry is a string containing the full path to an image in the graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filelist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">):</span>
            <span class="n">filelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;image_path&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">filelist</span></div>

<div class="viewcode-block" id="CandidateGraph.island_nodes"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.island_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">island_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds single nodes that are completely disconnected from the rest of the graph</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : list</span>
<span class="sd">          A list of disconnected nodes, nodes of degree zero, island nodes, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">isolates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.connected_subgraphs"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.connected_subgraphs">[docs]</a>    <span class="k">def</span> <span class="nf">connected_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds and returns a list of each connected subgraph of nodes. Each subgraph is a set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">         : list</span>
<span class="sd">           A list of connected sub-graphs of nodes, with the largest sub-graph first. Each subgraph is a set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.serials"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.serials">[docs]</a>    <span class="k">def</span> <span class="nf">serials</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a dictionary of ISIS3 compliant serial numbers for each</span>
<span class="sd">        node in the graph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        serials : dict</span>
<span class="sd">                  with key equal to the node id and value equal to</span>
<span class="sd">                  an ISIS3 compliant serial number or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">serials</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">):</span>
            <span class="n">serials</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">generate_serial_number</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;image_path&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">serials</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of all full file PATHs in the CandidateGraph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;image_path&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)]</span>

<div class="viewcode-block" id="CandidateGraph.save"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the graph object to disk.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">                   The relative or absolute PATH where the network is saved</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">io_network</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.plot"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the graph object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : object</span>
<span class="sd">             A MatPlotLib axes object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">         : object</span>
<span class="sd">           A MatPlotLib axes object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">plot_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.plot_cluster"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.plot_cluster">[docs]</a>    <span class="k">def</span> <span class="nf">plot_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the graph based on the clusters generated by</span>
<span class="sd">        the markov clustering algorithm</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : object</span>
<span class="sd">             A MatPlotLib axes object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : object</span>
<span class="sd">             A MatPlotLib axes object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cluster_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.create_node_subgraph"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.create_node_subgraph">[docs]</a>    <span class="k">def</span> <span class="nf">create_node_subgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of nodes, create a sub-graph and</span>
<span class="sd">        copy both the node and edge attributes to the subgraph.</span>
<span class="sd">        Changes to node/edge attributes are propagated back to the</span>
<span class="sd">        parent graph, while changes to the graph structure, i.e.,</span>
<span class="sd">        the topology, are not.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes : iterable</span>
<span class="sd">                An iterable (list, set, ndarray) of nodes to subset</span>
<span class="sd">                the graph</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        H : object</span>
<span class="sd">            A networkX graph object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.create_edge_subgraph"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.create_edge_subgraph">[docs]</a>    <span class="k">def</span> <span class="nf">create_edge_subgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a subgraph using a list of edges.</span>
<span class="sd">        This is pulled directly from the networkx dev branch.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edges : list</span>
<span class="sd">                A list of edges in the form [(a,b), (c,d)] to retain</span>
<span class="sd">                in the subgraph</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        H : object</span>
<span class="sd">            A networkx subgraph object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_subgraph</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.size"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.size">[docs]</a>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This replaces the built-in size method to properly</span>
<span class="sd">        support Python 3 rounding.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weight : string or None, optional (default=None)</span>
<span class="sd">           The edge attribute that holds the numerical value used</span>
<span class="sd">           as a weight.  If None, then each edge has weight 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nedges : int</span>
<span class="sd">            The number of edges or sum of edge weights in the graph.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">weight</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">weight</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span></div>

<div class="viewcode-block" id="CandidateGraph.subgraph_from_matches"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.subgraph_from_matches">[docs]</a>    <span class="k">def</span> <span class="nf">subgraph_from_matches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a sub-graph where all edges have matches.</span>
<span class="sd">        (i.e. images with no matches are removed)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : Object</span>
<span class="sd">          A networkX graph object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get all edges that have matches</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="p">[(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
                   <span class="k">if</span> <span class="ow">not</span> <span class="n">edge</span><span class="o">.</span><span class="n">matches</span><span class="o">.</span><span class="n">empty</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_edge_subgraph</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.filter_nodes"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.filter_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">filter_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filters graph and returns a sub-graph from matches. Mimics</span>
<span class="sd">        python&#39;s filter() function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : function which returns bool used to filter out nodes</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : Object</span>
<span class="sd">          A networkX graph object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span>
            <span class="s1">&#39;data&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_node_subgraph</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.filter_edges"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.filter_edges">[docs]</a>    <span class="k">def</span> <span class="nf">filter_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filters graph and returns a sub-graph from matches. Mimics</span>
<span class="sd">        python&#39;s filter() function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : function which returns bool used to filter out edges</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : Object</span>
<span class="sd">          A networkX graph object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">data</span><span class="p">(</span>
            <span class="s1">&#39;data&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_edge_subgraph</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.compute_cliques"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.compute_cliques">[docs]</a>    <span class="k">def</span> <span class="nf">compute_cliques</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes all maximum complete subgraphs for the given graph.</span>
<span class="sd">        If a node_id is given, method will return only the complete subgraphs that</span>
<span class="sd">        contain that node</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id : int</span>
<span class="sd">                       Integer value for a given node</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : list</span>
<span class="sd">          A list of lists of node ids that make up maximum complete subgraphs of the given graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">cliques_containing_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">node_id</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">find_cliques</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="CandidateGraph.compute_weight"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.compute_weight">[docs]</a>    <span class="k">def</span> <span class="nf">compute_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clean_keys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a voronoi weight for each edge in a given graph.</span>
<span class="sd">        Can function as is, but is slightly optimized for complete subgraphs.</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">                      keyword arguments that get passed to compute_voronoi</span>

<span class="sd">        clean_keys : list</span>
<span class="sd">                     Strings used to apply masks to omit correspondences</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_connected</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;The given graph is not complete and may yield garbage.&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;edge&#39;</span><span class="p">):</span>
            <span class="n">source_node</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">source</span>
            <span class="n">overlap</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_intersection</span><span class="p">(</span>
                <span class="n">source_node</span><span class="p">,</span> <span class="n">clean_keys</span><span class="o">=</span><span class="n">clean_keys</span><span class="p">)</span>

            <span class="n">matches</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">clean</span><span class="p">(</span><span class="n">clean_keys</span><span class="p">)</span>
            <span class="n">kps</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">get_keypoints</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">matches</span><span class="p">[</span><span class="s1">&#39;source_idx&#39;</span><span class="p">])[</span>
                <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]]</span>
            <span class="n">reproj_geom</span> <span class="o">=</span> <span class="n">source_node</span><span class="o">.</span><span class="n">reproject_geom</span><span class="p">(</span>
                <span class="n">overlap</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">__geo_interface__</span><span class="p">[</span><span class="s1">&#39;coordinates&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">initial_mask</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">geom_mask</span><span class="p">(</span><span class="n">kps</span><span class="p">,</span> <span class="n">reproj_geom</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kps</span><span class="p">[</span><span class="n">initial_mask</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">kps</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kps</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">kps_mask</span> <span class="o">=</span> <span class="n">kps</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="n">initial_mask</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">reproj_geom</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">voronoi_df</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">compute_voronoi</span><span class="p">(</span>
                <span class="n">kps</span><span class="p">[</span><span class="n">initial_mask</span><span class="p">][</span><span class="n">kps_mask</span><span class="p">],</span> <span class="n">reproj_geom</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">][</span><span class="s1">&#39;voronoi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">voronoi_df</span></div>

<div class="viewcode-block" id="CandidateGraph.compute_unique_fully_connected_components"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.compute_unique_fully_connected_components">[docs]</a>    <span class="k">def</span> <span class="nf">compute_unique_fully_connected_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a list of all cliques with size greater than size.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : int</span>
<span class="sd">               Only cliques larger than size are returned.  Default 2.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">         : list</span>
<span class="sd">           of lists of node ids</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; G = CandidateGraph()</span>
<span class="sd">        &gt;&gt;&gt; G.add_edges_from([(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;D&#39;), (&#39;A&#39;, &#39;E&#39;), (&#39;A&#39;, &#39;F&#39;), (&#39;E&#39;, &#39;F&#39;) ])</span>
<span class="sd">        &gt;&gt;&gt; res = G.compute_unique_fully_connected_components()</span>
<span class="sd">        &gt;&gt;&gt; sorted(map(sorted,res))</span>
<span class="sd">        [[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;], [&#39;A&#39;, &#39;E&#39;, &#39;F&#39;]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">enumerate_all_cliques</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">]</span></div>

<div class="viewcode-block" id="CandidateGraph.compute_fully_connected_components"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.compute_fully_connected_components">[docs]</a>    <span class="k">def</span> <span class="nf">compute_fully_connected_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a given graph, compute all of the fully connected subgraphs with</span>
<span class="sd">        3+ components.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fc : list</span>
<span class="sd">             of lists of node identifiers</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; G = CandidateGraph()</span>
<span class="sd">        &gt;&gt;&gt; G.add_edges_from([(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;D&#39;), (&#39;A&#39;, &#39;E&#39;), (&#39;A&#39;, &#39;F&#39;), (&#39;E&#39;, &#39;F&#39;) ])</span>
<span class="sd">        &gt;&gt;&gt; fc = G.compute_fully_connected_components()</span>
<span class="sd">        &gt;&gt;&gt; len(fc) #A, B, C, E, A  - D is omitted because it is a singular terminal node</span>
<span class="sd">        5</span>
<span class="sd">        &gt;&gt;&gt; sorted(map(sorted,fc[&#39;A&#39;]))  # Sort inner and outer lists</span>
<span class="sd">        [[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;], [&#39;A&#39;, &#39;E&#39;, &#39;F&#39;]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fully_connected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_unique_fully_connected_components</span><span class="p">()</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fully_connected</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">fc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">fc</span></div>

<div class="viewcode-block" id="CandidateGraph.compute_intersection"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.compute_intersection">[docs]</a>    <span class="k">def</span> <span class="nf">compute_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">clean_keys</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the intercetion of all images in a graph</span>
<span class="sd">        based around a given source node</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source: object or int</span>
<span class="sd">                     Either a networkx Node object or an integer</span>

<span class="sd">        clean_keys : list</span>
<span class="sd">                           Strings used to apply masks to omit correspondences</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        intersect_gdf : dataframe</span>
<span class="sd">                               A geopandas dataframe of intersections for all images</span>
<span class="sd">                               that overlap with the source node. Also includes the common</span>
<span class="sd">                               overlap for all images in the source node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
        <span class="c1"># May want to use a try except block here, but what error to raise?</span>
        <span class="n">source_poly</span> <span class="o">=</span> <span class="n">swkt</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span>
            <span class="n">source</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">footprint</span><span class="o">.</span><span class="n">GetGeometryRef</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ExportToWkt</span><span class="p">())</span>

        <span class="n">source_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="p">{</span><span class="s1">&#39;geometry&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">source_poly</span><span class="p">],</span> <span class="s1">&#39;source_node&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]]})</span>

        <span class="n">proj_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;proj_node&#39;</span><span class="p">])</span>
        <span class="n">proj_poly_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">proj_node_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Begin iterating through the edges in the graph that include the source node</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">source</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]:</span>
                <span class="n">proj_poly</span> <span class="o">=</span> <span class="n">swkt</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span>
                    <span class="n">edge</span><span class="o">.</span><span class="n">destination</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">footprint</span><span class="o">.</span><span class="n">GetGeometryRef</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ExportToWkt</span><span class="p">())</span>
                <span class="n">proj_poly_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proj_poly</span><span class="p">)</span>
                <span class="n">proj_node_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">d</span> <span class="o">==</span> <span class="n">source</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">]:</span>
                <span class="n">proj_poly</span> <span class="o">=</span> <span class="n">swkt</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span>
                    <span class="n">edge</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">footprint</span><span class="o">.</span><span class="n">GetGeometryRef</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ExportToWkt</span><span class="p">())</span>
                <span class="n">proj_poly_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proj_poly</span><span class="p">)</span>
                <span class="n">proj_node_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="n">proj_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">proj_poly_list</span><span class="p">,</span> <span class="s2">&quot;proj_node&quot;</span><span class="p">:</span> <span class="n">proj_node_list</span><span class="p">})</span>
        <span class="c1"># Overlay all geometry and find the one geometry element that overlaps all of the images</span>
        <span class="n">intersect_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">source_gdf</span><span class="p">,</span> <span class="n">proj_gdf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;intersection&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersect_gdf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Node &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; does not overlap with any other images in the candidate graph.&#39;</span><span class="p">)</span>
        <span class="n">overlaps_mask</span> <span class="o">=</span> <span class="n">intersect_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">proj_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">affinity</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">.</span><span class="mi">9</span><span class="p">,</span> <span class="o">.</span><span class="mi">9</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
        <span class="n">overlaps_all</span> <span class="o">=</span> <span class="n">intersect_gdf</span><span class="p">[</span><span class="n">overlaps_mask</span><span class="p">]</span>

        <span class="c1"># If there is no intersection polygon that overlaps all of the images, union all of the intersection</span>
        <span class="c1"># polygons into one large polygon that does overlap all of the images</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlaps_all</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_poly</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">unary_union</span><span class="p">(</span><span class="n">intersect_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>
            <span class="n">overlaps_all</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s1">&#39;source_node&#39;</span><span class="p">:</span> <span class="n">source</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">],</span> <span class="s1">&#39;proj_node&#39;</span><span class="p">:</span> <span class="n">source</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">],</span>
                                             <span class="s1">&#39;geometry&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">new_poly</span><span class="p">]})</span>

        <span class="k">return</span> <span class="n">overlaps_all</span><span class="p">,</span> <span class="n">intersect_gdf</span></div>

<div class="viewcode-block" id="CandidateGraph.is_complete"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.is_complete">[docs]</a>    <span class="k">def</span> <span class="nf">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the graph is a complete graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nneighbors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nneighbors</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="nf">footprints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">geoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">):</span>
            <span class="n">geoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">footprint</span><span class="p">)</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;image_name&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geoms</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">identify_potential_overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">control</span><span class="o">.</span><span class="n">identify_potential_overlaps</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">controlnetwork</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cc</span>

    <span class="k">def</span> <span class="nf">nodes_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">i</span>

    <span class="k">def</span> <span class="nf">edges_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span>

<div class="viewcode-block" id="CandidateGraph.generate_control_network"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.generate_control_network">[docs]</a>    <span class="k">def</span> <span class="nf">generate_control_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clean_keys</span><span class="o">=</span><span class="p">[],</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a fresh control network from edge matches.</span>

<span class="sd">        parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        clean_keys : list</span>
<span class="sd">                     A list of clean keys, same that would be used to filter edges</span>

<span class="sd">        mask</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">add_measure</span><span class="p">(</span><span class="n">lis</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">match_idx</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">point_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Create a new measure that is coincident to a given point.  This method does not</span>
<span class="sd">            create the point if is missing.  When a measure is added to the graph, an associated</span>
<span class="sd">            row is added to the measures dataframe.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            key : hashable</span>
<span class="sd">                      Some hashable id.  In the case of an autocnet graph object the</span>
<span class="sd">                      id should be in the form (image_id, match_id)</span>

<span class="sd">            point_id : hashable</span>
<span class="sd">                       The point to link the node to.  This is most likely an integer, but</span>
<span class="sd">                       any hashable should work.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_to_point</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">point_id</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">point_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">measure_to_point</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">point_id</span>
            <span class="c1"># The node_id is a composite key (image_id, correspondence_id), so just grab the image</span>
            <span class="n">image_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">match_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">lis</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">point_id</span><span class="p">,</span> <span class="n">image_id</span><span class="p">,</span> <span class="n">match_id</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">match_idx</span><span class="p">),</span> <span class="o">*</span><span class="n">fields</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_measure_id</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># TODO: get rid of these wack variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">measure_to_point</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_measure_id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">point_id</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">matches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matches</span><span class="p">(</span><span class="n">clean_keys</span><span class="p">)</span>
        <span class="n">cnet_lis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">to_records</span><span class="p">():</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">source_image</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">destination_image</span><span class="p">)</span>
                <span class="n">source_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">source_image</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">destination_image</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">source_idx</span><span class="p">)</span>
                <span class="n">source_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">source_x</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">source_y</span><span class="p">]</span>
                <span class="n">destin_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">destination_image</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">source_image</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">destination_idx</span><span class="p">)</span>
                <span class="n">destin_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">destination_x</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">destination_y</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_to_point</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">source_key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tempid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_to_point</span><span class="p">[</span><span class="n">source_key</span><span class="p">]</span>
                    <span class="n">add_measure</span><span class="p">(</span><span class="n">cnet_lis</span><span class="p">,</span> <span class="n">destin_key</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="n">destin_fields</span><span class="p">,</span> <span class="n">point_id</span><span class="o">=</span><span class="n">tempid</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_to_point</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">destin_key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tempid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_to_point</span><span class="p">[</span><span class="n">destin_key</span><span class="p">]</span>
                    <span class="n">add_measure</span><span class="p">(</span><span class="n">cnet_lis</span><span class="p">,</span> <span class="n">source_key</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="n">source_fields</span><span class="p">,</span> <span class="n">point_id</span><span class="o">=</span><span class="n">tempid</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">add_measure</span><span class="p">(</span><span class="n">cnet_lis</span><span class="p">,</span> <span class="n">source_key</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="n">source_fields</span><span class="p">)</span>
                    <span class="n">add_measure</span><span class="p">(</span><span class="n">cnet_lis</span><span class="p">,</span> <span class="n">destin_key</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="n">destin_fields</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_point_id</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">controlnetwork</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">cnet_lis</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">measures_keys</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">controlnetwork</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;measure_id&#39;</span></div>

    <span class="k">def</span> <span class="nf">remove_measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">controlnetwork</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">controlnetwork</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">controlnetwork</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">measure_to_point</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="CandidateGraph.validate_points"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.validate_points">[docs]</a>    <span class="k">def</span> <span class="nf">validate_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure that all control points currently in the nework are valid.</span>
<span class="sd">        Criteria for validity:</span>
<span class="sd">        * Singularity: A control point can have one and only one measure from any image</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : pd.Series</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
            <span class="c1"># One and only one measure constraint</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">image_index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">controlnetwork</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;point_id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.clean_singles"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.clean_singles">[docs]</a>    <span class="k">def</span> <span class="nf">clean_singles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Take the `controlnetwork` dataframe and return only those points with</span>
<span class="sd">        at least two measures.  This is automatically called before writing</span>
<span class="sd">        as functions such as subpixel matching can result in orphaned measures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">controlnetwork</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;point_id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="n">g</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="CandidateGraph.to_isis"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.to_isis">[docs]</a>    <span class="k">def</span> <span class="nf">to_isis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outname</span><span class="p">,</span> <span class="n">flistpath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="s2">&quot;Mars&quot;</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the control network out to the ISIS3 control network format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">controlnetwork</span>

        <span class="n">serials</span> <span class="o">=</span> <span class="p">[</span><span class="n">generate_serial_number</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">id_</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">][</span><span class="s2">&quot;image_path&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">id_</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;image_index&quot;</span><span class="p">]]</span>

        <span class="c1">#create columns in the dataframe; zeros ensure plio (/protobuf) will</span>
        <span class="c1">#ignore unless populated with alternate values</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;aprioriX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;aprioriY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;aprioriZ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;adjustedX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;adjustedY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;adjustedZ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;measureType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;serialnumber&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">serials</span>

        <span class="c1">#only populate the new columns for ground points. Otherwise, isis will</span>
        <span class="c1">#recalculate the control point lat/lon from control measures which where</span>
        <span class="c1">#&quot;massaged&quot; by the phase and template matcher.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;point_id&#39;</span><span class="p">):</span>
            <span class="n">zero_group</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">apriori_geom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">zero_group</span><span class="o">.</span><span class="n">image_index</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">file_name</span><span class="p">,</span> <span class="n">zero_group</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">zero_group</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;image&#39;</span><span class="p">)[</span><span class="s1">&#39;BodyFixedCoordinate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">row</span><span class="p">[</span><span class="s1">&#39;aprioriX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">apriori_geom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">row</span><span class="p">[</span><span class="s1">&#39;aprioriY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">apriori_geom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">row</span><span class="p">[</span><span class="s1">&#39;aprioriZ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">apriori_geom</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>

        <span class="k">if</span> <span class="n">flistpath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flistpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">outname</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.lis&#39;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;image_index&#39;</span><span class="p">:</span><span class="s1">&#39;image_id&#39;</span><span class="p">,</span><span class="s1">&#39;point_id&#39;</span><span class="p">:</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span> <span class="p">:</span> <span class="s1">&#39;pointType&#39;</span><span class="p">,</span>
             <span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="s1">&#39;line&#39;</span><span class="p">})</span>
        <span class="n">cnet</span><span class="o">.</span><span class="n">to_isis</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">outname</span><span class="p">,</span> <span class="n">targetname</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
        <span class="n">cnet</span><span class="o">.</span><span class="n">write_filelist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">flistpath</span><span class="p">)</span></div>

<div class="viewcode-block" id="CandidateGraph.to_bal"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.CandidateGraph.to_bal">[docs]</a>    <span class="k">def</span> <span class="nf">to_bal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the control network out to the Bundle Adjustment in the Large</span>
<span class="sd">        (BAL) file format.  For more information see:</span>
<span class="sd">        http://grail.cs.washington.edu/projects/bal/</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>

<div class="viewcode-block" id="NetworkCandidateGraph"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.NetworkCandidateGraph">[docs]</a><span class="k">class</span> <span class="nc">NetworkCandidateGraph</span><span class="p">(</span><span class="n">CandidateGraph</span><span class="p">):</span>
    <span class="n">node_factory</span> <span class="o">=</span> <span class="n">NetworkNode</span>
    <span class="n">edge_factory</span> <span class="o">=</span> <span class="n">NetworkEdge</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NetworkCandidateGraph</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Job metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">job_status</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

        <span class="c1"># Set the parents of the nodes/edges and populate the database</span>
        <span class="c1"># if unpopulated.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">):</span>
            <span class="n">d</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">):</span>
            <span class="n">e</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="bp">self</span><span class="o">.</span> <span class="n">apply_iterable_options</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;edge&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span>
                <span class="s1">&#39;edges&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span>
                <span class="s1">&#39;e&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span>
                <span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span>
                <span class="s1">&#39;node&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
                <span class="s1">&#39;nodes&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
                <span class="s1">&#39;n&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
                <span class="mi">1</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
                <span class="s1">&#39;measures&#39;</span> <span class="p">:</span> <span class="n">Measures</span><span class="p">,</span>
                <span class="s1">&#39;measure&#39;</span> <span class="p">:</span> <span class="n">Measures</span><span class="p">,</span>
                <span class="s1">&#39;m&#39;</span> <span class="p">:</span> <span class="n">Measures</span><span class="p">,</span>
                <span class="mi">2</span> <span class="p">:</span> <span class="n">Measures</span><span class="p">,</span>
                <span class="s1">&#39;points&#39;</span> <span class="p">:</span> <span class="n">Points</span><span class="p">,</span>
                <span class="s1">&#39;point&#39;</span> <span class="p">:</span> <span class="n">Points</span><span class="p">,</span>
                <span class="s1">&#39;p&#39;</span> <span class="p">:</span> <span class="n">Points</span><span class="p">,</span>
                <span class="mi">3</span> <span class="p">:</span> <span class="n">Points</span><span class="p">,</span>
                <span class="s1">&#39;overlaps&#39;</span><span class="p">:</span> <span class="n">Overlay</span><span class="p">,</span>
                <span class="s1">&#39;overlap&#39;</span> <span class="p">:</span> <span class="n">Overlay</span><span class="p">,</span>
                <span class="s1">&#39;o&#39;</span> <span class="p">:</span><span class="n">Overlay</span><span class="p">,</span>
                <span class="mi">4</span><span class="p">:</span> <span class="n">Overlay</span>
            <span class="p">}</span>

<div class="viewcode-block" id="NetworkCandidateGraph.config_from_file"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.NetworkCandidateGraph.config_from_file">[docs]</a>    <span class="k">def</span> <span class="nf">config_from_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A NetworkCandidateGraph uses a database. This method parses a config</span>
<span class="sd">        file to set up the connection. Additionally, this loads planetary</span>
<span class="sd">        information and settings for other operations the candidate graph</span>
<span class="sd">        can perform.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filepath : str</span>
<span class="sd">                   The path to the config file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The YAML library will raise any parse errors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config_from_dict</span><span class="p">(</span><span class="n">parse_config</span><span class="p">(</span><span class="n">filepath</span><span class="p">))</span></div>

<div class="viewcode-block" id="NetworkCandidateGraph.config_from_dict"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.NetworkCandidateGraph.config_from_dict">[docs]</a>    <span class="k">def</span> <span class="nf">config_from_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A NetworkCandidateGraph uses a database. This method loads a config</span>
<span class="sd">        dict to set up the connection. Additionally, this loads planetary</span>
<span class="sd">        information and settings for other operations the candidate graph</span>
<span class="sd">        can perform.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filepath : str</span>
<span class="sd">                   The path to the config file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">config_dict</span>

        <span class="c1"># Setup REDIS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_queues</span><span class="p">()</span>

        <span class="c1"># Setup the database</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_database</span><span class="p">()</span>

        <span class="c1"># Setup the DEM</span>
        <span class="c1"># I dislike having the DEM on the NCG, but in the short term it</span>
        <span class="c1"># is the best solution I think. I don&#39;t want to pass the DEM around</span>
        <span class="c1"># for the sensor calls.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_dem</span><span class="p">()</span></div>

<div class="viewcode-block" id="NetworkCandidateGraph.session_scope"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.NetworkCandidateGraph.session_scope">[docs]</a>    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">session_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     Provide a transactional scope around a series of operations.</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="n">session</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span>
     <span class="k">try</span><span class="p">:</span>
         <span class="k">yield</span> <span class="n">session</span>
         <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
     <span class="k">except</span><span class="p">:</span>
         <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
         <span class="k">raise</span>
     <span class="k">finally</span><span class="p">:</span>
         <span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_setup_dem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">spatial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;spatial&#39;</span><span class="p">]</span>
        <span class="n">dem</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dem&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dem</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dem</span> <span class="o">=</span> <span class="n">GeoDataset</span><span class="p">(</span><span class="n">dem</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dem</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_setup_database</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;database&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Session</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span> <span class="o">=</span> <span class="n">new_connection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;database&#39;</span><span class="p">])</span>

        <span class="c1"># Attempt to create the database (if it does not exist)</span>
        <span class="n">try_db_creation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setup_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setup a 2 queue redis connection for pushing and pulling work/results</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;redis&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">redis_queue</span> <span class="o">=</span> <span class="n">StrictRedis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;host&#39;</span><span class="p">],</span>
                                       <span class="n">port</span><span class="o">=</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;port&#39;</span><span class="p">],</span>
                                       <span class="n">db</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processing_queue</span> <span class="o">=</span> <span class="n">conf</span><span class="p">[</span><span class="s1">&#39;processing_queue&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="NetworkCandidateGraph.empty_queues"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.NetworkCandidateGraph.empty_queues">[docs]</a>    <span class="k">def</span> <span class="nf">empty_queues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete all messages from the redis queue. This a convenience method.</span>
<span class="sd">        The `redis_queue` object is a redis-py StrictRedis object with API</span>
<span class="sd">        documented at: https://redis-py.readthedocs.io/en/latest/#redis.StrictRedis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">redis_queue</span><span class="o">.</span><span class="n">flushall</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_execute_sql</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sql</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute a raw SQL string in the database currently specified</span>
<span class="sd">        by the AutoCNet config file.</span>

<span class="sd">        Use this method with caution as you can easily do things like</span>
<span class="sd">        truncate a table.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sql : str</span>
<span class="sd">              The SQL string to be passed to the DB engine and executed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_push_obj_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onobj</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">walltime</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Push messages to the redis queue for objects e.g., Nodes and Edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">job_counter</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">onobj</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="c1"># Determine if we are working with an edge or a node</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">id</span> <span class="o">=</span> <span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">],</span>
                    <span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">destination</span><span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">])</span>
                <span class="n">image_path</span> <span class="o">=</span> <span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="s1">&#39;image_path&#39;</span><span class="p">],</span>
                            <span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">destination</span><span class="p">[</span><span class="s1">&#39;image_path&#39;</span><span class="p">])</span>
                <span class="n">along</span> <span class="o">=</span> <span class="s1">&#39;edge&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">id</span> <span class="o">=</span> <span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">image_path</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;image_path&#39;</span><span class="p">]</span>
                <span class="n">along</span> <span class="o">=</span> <span class="s1">&#39;node&#39;</span>

            <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="nb">id</span><span class="p">,</span>
                   <span class="s1">&#39;along&#39;</span><span class="p">:</span><span class="n">along</span><span class="p">,</span>
                    <span class="s1">&#39;func&#39;</span><span class="p">:</span><span class="n">function</span><span class="p">,</span>
                    <span class="s1">&#39;args&#39;</span><span class="p">:</span><span class="n">args</span><span class="p">,</span>
                    <span class="s1">&#39;kwargs&#39;</span><span class="p">:</span><span class="n">kwargs</span><span class="p">,</span>
                    <span class="s1">&#39;walltime&#39;</span><span class="p">:</span><span class="n">walltime</span><span class="p">,</span>
                    <span class="s1">&#39;image_path&#39;</span><span class="p">:</span><span class="n">image_path</span><span class="p">,</span>
                    <span class="s1">&#39;param_step&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                    <span class="s1">&#39;config&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">}</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">redis_queue</span><span class="o">.</span><span class="n">rpush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processing_queue</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">JsonEncoder</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">job_counter</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_push_row_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_obj</span><span class="p">,</span> <span class="n">on</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">walltime</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">query_string</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Push messages to the redis queue for DB objects e.g., Points, Measures</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filters</span> <span class="ow">and</span> <span class="n">query_string</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Use of filters and query_string are mutually exclusive.&#39;</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">session_scope</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">query_obj</span><span class="p">)</span>

            <span class="c1"># Now apply any filters that might be passed in.</span>
            <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">filters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">query</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">query_obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">==</span><span class="n">value</span><span class="p">)</span>

            <span class="c1"># Execute the query to get the rows to be processed</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

            <span class="c1"># Support either an SQL query string, or a simple dict based query</span>
            <span class="k">if</span> <span class="n">query_string</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">query_string</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">query_obj</span><span class="p">)</span>

                <span class="c1"># Now apply any filters that might be passed in.</span>
                <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">filters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">query</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">query_obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">==</span><span class="n">value</span><span class="p">)</span>

                <span class="c1"># Execute the query to get the rows to be processed</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Query returned zero results.&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;along&#39;</span><span class="p">:</span><span class="n">on</span><span class="p">,</span>
                        <span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="n">row</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                        <span class="s1">&#39;func&#39;</span><span class="p">:</span><span class="n">function</span><span class="p">,</span>
                        <span class="s1">&#39;args&#39;</span><span class="p">:</span><span class="n">args</span><span class="p">,</span>
                        <span class="s1">&#39;kwargs&#39;</span><span class="p">:</span><span class="n">kwargs</span><span class="p">,</span>
                        <span class="s1">&#39;walltime&#39;</span><span class="p">:</span><span class="n">walltime</span><span class="p">}</span>
                <span class="n">msg</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span>  <span class="c1"># Hacky for now, just passs the whole config dict</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">redis_queue</span><span class="o">.</span><span class="n">rpush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processing_queue</span><span class="p">,</span>
                                    <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">JsonEncoder</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

<div class="viewcode-block" id="NetworkCandidateGraph.apply"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.NetworkCandidateGraph.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">walltime</span><span class="o">=</span><span class="s1">&#39;01:00:00&#39;</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{},</span> <span class="n">query_string</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A mirror of the apply function from the standard CandidateGraph object. This implementation</span>
<span class="sd">        dispatches the job to the cluster as an independent operation instead of applying an arbitrary function</span>
<span class="sd">        locally.</span>

<span class="sd">        This methods returns the number of jobs submitted. The job status is then asynchronously</span>
<span class="sd">        updated as the jobs complete.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        function : string</span>
<span class="sd">                   The function to apply</span>

<span class="sd">        on : str</span>
<span class="sd">             {&#39;edge&#39;, &#39;edges&#39;, &#39;e&#39;, 0} for an edge</span>
<span class="sd">             {&#39;node&#39;, &#39;nodes&#39;, &#39;n&#39; 1} for a node</span>
<span class="sd">             {&#39;measures&#39;, &#39;measure&#39;, &#39;m&#39;, &#39;2&#39;} for measures</span>
<span class="sd">             {&#39;points&#39;, &#39;point&#39;, &#39;p&#39;, &#39;3&#39;} for points</span>

<span class="sd">        args : tuple</span>
<span class="sd">               Of additional arguments to pass to the apply function</span>

<span class="sd">        walltime : str</span>
<span class="sd">                   in the format Hour:Minute:Second, 00:00:00</span>

<span class="sd">        chunksize : int</span>
<span class="sd">                    The maximum number of jobs to submit per job array. Defaults to 1000.</span>
<span class="sd">                    This number may be have an actualy higher or lower limited based on</span>
<span class="sd">                    how the cluster has been configured.</span>

<span class="sd">        filters : dict</span>
<span class="sd">                  Of simple filters to apply on database rows where the key is the attribute and</span>
<span class="sd">                  the value used to check equivalency (e.g., attribute == value).</span>
<span class="sd">                  This is usable only when applying to measures, points, or overlays.</span>
<span class="sd">                  Filters can not be used with a query_string. Filters are included as a convenience</span>
<span class="sd">                  and are really only usable for simple equivalency checks.</span>

<span class="sd">        query_string : str</span>
<span class="sd">                       A SQL query to be applied to the iterable.</span>
<span class="sd">                       This is usable only when applying to measures, points, or overlays.</span>
<span class="sd">                       The query_string can not be used with a filter and is appropriate for</span>
<span class="sd">                       any queries.</span>

<span class="sd">        kwargs : dict</span>
<span class="sd">                 Of keyword arguments passed to the function being applied</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Apply a function to the overlay table omitting those overlay rows that already have</span>
<span class="sd">        points within them and have an area less than a given threshold.</span>

<span class="sd">        &gt;&gt;&gt; query_string = &#39;SELECT overlay.id FROM overlay LEFT JOIN\</span>
<span class="sd">            points ON ST_INTERSECTS(overlay.geom, points.geom) WHERE\</span>
<span class="sd">                points.id IS NULL AND ST_AREA(overlay.geom) &gt;= 0.0001;&#39;</span>
<span class="sd">        &gt;&gt;&gt; njobs = ncg.apply(&#39;spatial.overlap.place_points_in_overlap&#39;, on=&#39;overlaps&#39;, query_string=query_string)</span>

<span class="sd">        Apply a function to the overlay table and pass keyword arguments (kwargs) to the function.</span>

<span class="sd">        &gt;&gt;&gt; def ns(x):</span>
<span class="sd">                from math import ceil</span>
<span class="sd">                return ceil(round(x,1)*8)</span>
<span class="sd">        &gt;&gt;&gt; def ew(x):</span>
<span class="sd">                from math import ceil</span>
<span class="sd">                return ceil(round(x,1)*2)</span>
<span class="sd">        &gt;&gt;&gt; distribute_points_kwargs = {&#39;nspts_func&#39;:ns, &#39;ewpts_func&#39;:ew, &#39;method&#39;:&#39;classic&#39;}</span>
<span class="sd">        &gt;&gt;&gt; njobs = ncg.apply(&#39;spatial.overlap.place_points_in_overlap&#39;,\</span>
<span class="sd">            on=&#39;overlaps&#39;, distribute_points_kwargs=distribute_points_kwargs)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Determine which obj will be called</span>
        <span class="n">onobj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_iterable_options</span><span class="p">[</span><span class="n">on</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Function argument must be a string or bytes object.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onobj</span><span class="p">,</span> <span class="n">DeclarativeMeta</span><span class="p">):</span>
            <span class="n">job_counter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_push_row_messages</span><span class="p">(</span><span class="n">onobj</span><span class="p">,</span> <span class="n">on</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">walltime</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">query_string</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">job_counter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_push_obj_messages</span><span class="p">(</span><span class="n">onobj</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">walltime</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>


        <span class="c1"># Submit the jobs</span>
        <span class="n">rconf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;redis&#39;</span><span class="p">]</span>
        <span class="n">rhost</span> <span class="o">=</span> <span class="n">rconf</span><span class="p">[</span><span class="s1">&#39;host&#39;</span><span class="p">]</span>
        <span class="n">rport</span> <span class="o">=</span> <span class="n">rconf</span><span class="p">[</span><span class="s1">&#39;port&#39;</span><span class="p">]</span>
        <span class="n">processing_queue</span> <span class="o">=</span> <span class="n">rconf</span><span class="p">[</span><span class="s1">&#39;processing_queue&#39;</span><span class="p">]</span>

        <span class="n">env</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;env&#39;</span><span class="p">]</span>
        <span class="n">condaenv</span> <span class="o">=</span> <span class="n">env</span><span class="p">[</span><span class="s1">&#39;conda&#39;</span><span class="p">]</span>
        <span class="n">isisroot</span> <span class="o">=</span> <span class="n">env</span><span class="p">[</span><span class="s1">&#39;ISISROOT&#39;</span><span class="p">]</span>
        <span class="n">isisdata</span> <span class="o">=</span> <span class="n">env</span><span class="p">[</span><span class="s1">&#39;ISISDATA&#39;</span><span class="p">]</span>

        <span class="n">isissetup</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;export ISISROOT=</span><span class="si">{</span><span class="n">isisroot</span><span class="si">}</span><span class="s1"> &amp;&amp; export ISIS3DATA=</span><span class="si">{</span><span class="n">isisdata</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">condasetup</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;conda activate </span><span class="si">{</span><span class="n">condaenv</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">job</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;acn_submit -r=</span><span class="si">{</span><span class="n">rhost</span><span class="si">}</span><span class="s1"> -p=</span><span class="si">{</span><span class="n">rport</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">processing_queue</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">command</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">condasetup</span><span class="si">}</span><span class="s1"> &amp;&amp; </span><span class="si">{</span><span class="n">isissetup</span><span class="si">}</span><span class="s1"> &amp;&amp; </span><span class="si">{</span><span class="n">job</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="n">submitter</span> <span class="o">=</span> <span class="n">Slurm</span><span class="p">(</span><span class="n">command</span><span class="p">,</span>
                     <span class="n">job_name</span><span class="o">=</span><span class="s1">&#39;AutoCNet&#39;</span><span class="p">,</span>
                     <span class="n">mem_per_cpu</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">][</span><span class="s1">&#39;processing_memory&#39;</span><span class="p">],</span>
                     <span class="n">time</span><span class="o">=</span><span class="n">walltime</span><span class="p">,</span>
                     <span class="n">partition</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">][</span><span class="s1">&#39;queue&#39;</span><span class="p">],</span>
                     <span class="n">output</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">][</span><span class="s1">&#39;cluster_log_dir&#39;</span><span class="p">]</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;/autocnet.</span><span class="si">{</span><span class="n">function</span><span class="si">}</span><span class="s1">-%j&#39;</span><span class="p">)</span>
        <span class="n">submitter</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">array</span><span class="o">=</span><span class="s1">&#39;1-</span><span class="si">{}</span><span class="s1">%25&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">job_counter</span><span class="p">),</span> <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">job_counter</span></div>

<div class="viewcode-block" id="NetworkCandidateGraph.generic_callback"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.NetworkCandidateGraph.generic_callback">[docs]</a>    <span class="k">def</span> <span class="nf">generic_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method manages the responses from the jobs and updates</span>
<span class="sd">        the status on this object. The msg is in a standard, parseable</span>
<span class="sd">        format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="n">msg</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="c1"># Working with a node</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="nb">id</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="nb">id</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
            <span class="c1"># Working with an edge</span>

        <span class="n">func</span> <span class="o">=</span> <span class="n">msg</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">job_status</span><span class="p">[</span><span class="n">func</span><span class="p">][</span><span class="s1">&#39;success&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">]</span>

        <span class="c1"># If the job was successful, no need to resubmit</span>
        <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span></div>

<div class="viewcode-block" id="NetworkCandidateGraph.to_isis"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.NetworkCandidateGraph.to_isis">[docs]</a>    <span class="k">def</span> <span class="nf">to_isis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">path</span><span class="p">,</span>
                <span class="n">flistpath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">latsigma</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                <span class="n">lonsigma</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                <span class="n">radsigma</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
                <span class="o">**</span><span class="n">db_kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write a NetworkCandidateGraph to an ISIS control network</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">               Outpath to write the control network</span>

<span class="sd">        flishpath : str</span>
<span class="sd">                    Outpath to write the associated file list. If None (default),</span>
<span class="sd">                    the file list is written alongside the control network</span>

<span class="sd">        latsigma : int/float</span>
<span class="sd">               The estimated sigma (error) in the latitude direction</span>

<span class="sd">        lonsigma : int/float</span>
<span class="sd">                The estimated sigma (error) in the longitude direction</span>

<span class="sd">        radsigma : int/float</span>
<span class="sd">                The estimated sigma (error) in the radius direction</span>

<span class="sd">        radius : int/float</span>
<span class="sd">                The body semimajor radius</span>

<span class="sd">        db_kwargs : dict</span>
<span class="sd">                    Kwargs that are passed to the io.db.controlnetwork.db_to_df function</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Read the cnet from the db</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">io_controlnetwork</span><span class="o">.</span><span class="n">db_to_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="p">,</span> <span class="o">**</span><span class="n">db_kwargs</span><span class="p">)</span>

        <span class="c1"># Add the covariance matrices to ground measures</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">control</span><span class="o">.</span><span class="n">compute_covariance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span>
                                        <span class="n">latsigma</span><span class="p">,</span>
                                        <span class="n">lonsigma</span><span class="p">,</span>
                                        <span class="n">radsigma</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;spatial&#39;</span><span class="p">][</span><span class="s1">&#39;semimajor_rad&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">flistpath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flistpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.lis&#39;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;spatial&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;target&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">ids</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;imageid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">fpaths</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;image_path&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fpaths</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s1"> in candidate graph but not in output network.&#39;</span><span class="p">)</span>

        <span class="c1"># Remap the df columns back to ISIS</span>
        <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;pointtype&#39;</span><span class="p">:</span><span class="s1">&#39;pointType&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;measuretype&#39;</span><span class="p">:</span><span class="s1">&#39;measureType&#39;</span><span class="p">},</span>
                           <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">cnet</span><span class="o">.</span><span class="n">to_isis</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">targetname</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
        <span class="n">cnet</span><span class="o">.</span><span class="n">write_filelist</span><span class="p">(</span><span class="n">fpaths</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">flistpath</span><span class="p">)</span></div>

<div class="viewcode-block" id="NetworkCandidateGraph.update_from_jigsaw"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.NetworkCandidateGraph.update_from_jigsaw">[docs]</a>    <span class="k">def</span> <span class="nf">update_from_jigsaw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the measures table in the database with data from</span>
<span class="sd">        a jigsaw bundle adjust</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">               Full path to a bundle adjusted isis control network</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ingest isis control net as a df and do some massaging</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">cnet</span><span class="o">.</span><span class="n">from_isis</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">data_to_update</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;serialnumber&#39;</span><span class="p">,</span> <span class="s1">&#39;measureJigsawRejected&#39;</span><span class="p">,</span> <span class="s1">&#39;sampleResidual&#39;</span><span class="p">,</span> <span class="s1">&#39;lineResidual&#39;</span><span class="p">,</span> <span class="s1">&#39;samplesigma&#39;</span><span class="p">,</span> <span class="s1">&#39;linesigma&#39;</span><span class="p">,</span> <span class="s1">&#39;adjustedCovar&#39;</span><span class="p">,</span> <span class="s1">&#39;apriorisample&#39;</span><span class="p">,</span> <span class="s1">&#39;aprioriline&#39;</span><span class="p">]]</span>
        <span class="n">data_to_update</span><span class="p">[</span><span class="s1">&#39;adjustedCovar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_to_update</span><span class="p">[</span><span class="s1">&#39;adjustedCovar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span> <span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">))</span>
        <span class="n">data_to_update</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_to_update</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">))</span>

        <span class="c1"># Generate a temp table, update the real table, then drop the temp table</span>
        <span class="n">data_to_update</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="s1">&#39;temp_measures&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">,</span> <span class="n">index_label</span><span class="o">=</span><span class="s1">&#39;serialnumber&#39;</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">sql</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        UPDATE measures AS f</span>
<span class="s2">        SET &quot;measureJigsawRejected&quot; = t.&quot;measureJigsawRejected&quot;, sampler = t.&quot;sampleResidual&quot;, liner = t.&quot;lineResidual&quot;, samplesigma = t.&quot;samplesigma&quot;, linesigma = t.&quot;linesigma&quot;, apriorisample = t.&quot;apriorisample&quot;, aprioriline = t.&quot;aprioriline&quot;</span>
<span class="s2">        FROM temp_measures AS t</span>
<span class="s2">        WHERE f.serialnumber = t.serialnumber AND f.pointid = t.id;</span>

<span class="s2">        DROP TABLE temp_measures;</span>
<span class="s2">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">session_scope</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>
            <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></div>

<div class="viewcode-block" id="NetworkCandidateGraph.from_filelist"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.NetworkCandidateGraph.from_filelist">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_filelist</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filelist</span><span class="p">,</span> <span class="n">clear_db</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse a filelist to add nodes to the database. Using the</span>
<span class="sd">        information in the database, then instantiate a complete,</span>
<span class="sd">        NCG.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filelist : list, str</span>
<span class="sd">                   If a list, this is a list of paths. If a str, this is</span>
<span class="sd">                   a path to a file containing a list of image paths</span>
<span class="sd">                   that is newline (&quot;\\n&quot;) delimited.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ncg : object</span>
<span class="sd">              A network candidate graph object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filelist</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
            <span class="n">filelist</span> <span class="o">=</span> <span class="n">io_utils</span><span class="o">.</span><span class="n">file_to_list</span><span class="p">(</span><span class="n">filelist</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Unable to parse the passed filelist&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clear_db</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">clear_db</span><span class="p">()</span>

        <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">filelist</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
            <span class="c1"># Create the nodes in the graph. Really, this is creating the</span>
            <span class="c1"># images in the DB</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;loading </span><span class="si">{}</span><span class="s1"> of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cnt</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">total</span><span class="p">))</span>
            <span class="n">image_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">NetworkNode</span><span class="p">(</span><span class="n">image_path</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">image_name</span><span class="o">=</span><span class="n">image_name</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_database</span><span class="p">()</span>
        <span class="c1"># Execute the computation to compute overlapping geometries</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_execute_sql</span><span class="p">(</span><span class="n">compute_overlaps_sql</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="NetworkCandidateGraph.copy_images"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.NetworkCandidateGraph.copy_images">[docs]</a>    <span class="k">def</span> <span class="nf">copy_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newdir</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy images from a given directory into a new directory and</span>
<span class="sd">        update the &#39;path&#39; column in the Images table.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newdir : str</span>
<span class="sd">                 The full output PATH where the images are to be copied to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">newdir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">newdir</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">session_scope</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Images</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
                <span class="n">oldpath</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">path</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">oldpath</span><span class="p">)</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">newdir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">oldpath</span> <span class="o">!=</span> <span class="n">obj</span><span class="o">.</span><span class="n">path</span><span class="p">:</span>
                    <span class="c1"># Copy the files</span>
                    <span class="n">copyfile</span><span class="p">(</span><span class="n">oldpath</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                    <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span></div>

<div class="viewcode-block" id="NetworkCandidateGraph.add_from_remote_database"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.NetworkCandidateGraph.add_from_remote_database">[docs]</a>    <span class="k">def</span> <span class="nf">add_from_remote_database</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_db_config</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>  <span class="n">query_string</span><span class="o">=</span><span class="s1">&#39;SELECT * FROM public.images LIMIT 10&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a constructor that takes an existing database containing images and sensors,</span>
<span class="sd">        copies the selected rows into the project specified in the autocnet_config variable,</span>
<span class="sd">        and instantiates a new NetworkCandidateGraph object. This method is</span>
<span class="sd">        similar to the `from_database` method. The main difference is that this</span>
<span class="sd">        method assumes that the image and sensor rows are prepopulated in an external db</span>
<span class="sd">        and simply copies those entires into the currently speficied project.</span>

<span class="sd">        Currently, this method does NOT check for duplicate serial numbers during the</span>
<span class="sd">        bulk add. Therefore multiple runs of this method on the same database will fail.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_db_config : dict</span>
<span class="sd">                           In the form: {&#39;username&#39;:&#39;somename&#39;,</span>
<span class="sd">                                         &#39;password&#39;:&#39;somepassword&#39;,</span>
<span class="sd">                                         &#39;host&#39;:&#39;somehost&#39;,</span>
<span class="sd">                                         &#39;pgbouncer_port&#39;:6543,</span>
<span class="sd">                                         &#39;name&#39;:&#39;somename&#39;}</span>

<span class="sd">        path : str</span>
<span class="sd">               The PATH to which images in the database specified in the config</span>
<span class="sd">               will be copied to. This method duplicates the data and copies it</span>
<span class="sd">               to a user defined PATH to avoid issues with updating image ephemeris</span>
<span class="sd">               across projects.</span>

<span class="sd">        query_string : str</span>
<span class="sd">                       An optional string to select a subset of the images in the</span>
<span class="sd">                       database specified in the config.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : obj</span>
<span class="sd">              A network candidate graph.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; ncg = NetworkCandidateGraph()</span>
<span class="sd">        &gt;&gt;&gt; ncg.config_from_dict(new_config)</span>
<span class="sd">        &gt;&gt;&gt; source_db_config = {&#39;username&#39;:&#39;jay&#39;,</span>
<span class="sd">        &#39;password&#39;:&#39;abcde&#39;,</span>
<span class="sd">        &#39;host&#39;:&#39;autocnet.wr.usgs.gov&#39;,</span>
<span class="sd">        &#39;pgbouncer_port&#39;:5432,</span>
<span class="sd">        &#39;name&#39;:&#39;mars&#39;}</span>
<span class="sd">        &gt;&gt;&gt; geom = &#39;LINESTRING(145 10, 145 10.25, 145.25 10.25, 145.25 10, 145 10)&#39;</span>
<span class="sd">        &gt;&gt;&gt; srid = 949900</span>
<span class="sd">        &gt;&gt;&gt; outpath = &#39;/scratch/jlaura/fromdb&#39;</span>
<span class="sd">        &gt;&gt;&gt; query = f&quot;SELECT * FROM ctx WHERE ST_INTERSECTS(geom, ST_Polygon(ST_GeomFromText(&#39;{geom}&#39;), {srid})) = TRUE&quot;</span>
<span class="sd">        &gt;&gt;&gt; ncg.add_from_remote_database(source_db_config, outpath, query_string=query)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sourceSession</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">new_connection</span><span class="p">(</span><span class="n">source_db_config</span><span class="p">)</span>
        <span class="n">sourcesession</span> <span class="o">=</span> <span class="n">sourceSession</span><span class="p">()</span>

        <span class="n">sourceimages</span> <span class="o">=</span> <span class="n">sourcesession</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">query_string</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">session_scope</span><span class="p">()</span> <span class="k">as</span> <span class="n">destinationsession</span><span class="p">:</span>
            <span class="n">destinationsession</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">Images</span><span class="o">.</span><span class="n">__table__</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="n">sourceimages</span><span class="p">)</span>

            <span class="c1"># Get the camera objects to manually join. Keeps the caller from</span>
            <span class="c1"># having to remember to bring cameras as well.</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sourceimages</span><span class="p">]</span>
            <span class="c1">#cameras = sourcesession.query(Cameras).filter(Cameras.image_id.in_(ids)).all()</span>
            <span class="c1">#for c in cameras:</span>
            <span class="c1">#    destinationsession.merge(c)</span>

        <span class="n">sourcesession</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># Create the graph, copy the images, and compute the overlaps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy_images</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_database</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_execute_sql</span><span class="p">(</span><span class="n">compute_overlaps_sql</span><span class="p">)</span></div>

<div class="viewcode-block" id="NetworkCandidateGraph.from_database"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.NetworkCandidateGraph.from_database">[docs]</a>    <span class="k">def</span> <span class="nf">from_database</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_string</span><span class="o">=</span><span class="s1">&#39;SELECT * FROM public.images&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a constructor that takes the results from an arbitrary query string,</span>
<span class="sd">        uses those as a subquery into a standard polygon overlap query and</span>
<span class="sd">        returns a NetworkCandidateGraph object.  By default, an images</span>
<span class="sd">        in the Image table will be used in the outer query.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        query_string : str</span>
<span class="sd">                       A valid SQL select statement that targets the Images table</span>

<span class="sd">        Usage</span>
<span class="sd">        -----</span>
<span class="sd">        Here, we provide usage examples for a few, potentially common use cases.</span>

<span class="sd">        ## Spatial Query</span>
<span class="sd">        This example selects those images that intersect a given bounding polygon.  The polygon is</span>
<span class="sd">        specified as a Well Known Text LINESTRING with the first and last points being the same.</span>
<span class="sd">        The query says, select the geom (the bounding polygons in the database) that</span>
<span class="sd">        intersect the user provided polygon (the LINESTRING) in the given spatial reference system</span>
<span class="sd">        (SRID), 949900.</span>

<span class="sd">        SELECT * FROM Images WHERE ST_INTERSECTS(geom, ST_Polygon(ST_GeomFromText(&#39;LINESTRING(159 10, 159 11, 160 11, 160 10, 159 10)&#39;),949900)) = TRUE</span>

<span class="sd">        ## Select from a specific orbit</span>
<span class="sd">        This example selects those images that are from a particular orbit. In this case,</span>
<span class="sd">        the regex string pulls all P##_* orbits and creates a graph from them. This method</span>
<span class="sd">        does not guarantee that the graph is fully connected.</span>

<span class="sd">        SELECT * FROM Images WHERE (split_part(path, &#39;/&#39;, 6) ~ &#39;P[0-9]+_.+&#39;) = True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">composite_query</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;WITH i as (</span><span class="si">{}</span><span class="s1">) SELECT i1.id</span>
<span class="s1">        as i1_id,i1.path as i1_path, i2.id as i2_id, i2.path as i2_path</span>
<span class="s1">        FROM i  as i1, i as i2</span>
<span class="s1">        WHERE ST_INTERSECTS(i1.geom, i2.geom) = TRUE</span>
<span class="s1">        AND i1.id &lt; i2.id&#39;&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">query_string</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">session_scope</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">composite_query</span><span class="p">)</span>

            <span class="n">adjacency</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="n">adjacency_lookup</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                <span class="n">sid</span><span class="p">,</span> <span class="n">spath</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="n">dpath</span> <span class="o">=</span> <span class="n">r</span>

                <span class="n">adjacency_lookup</span><span class="p">[</span><span class="n">spath</span><span class="p">]</span> <span class="o">=</span> <span class="n">sid</span>
                <span class="n">adjacency_lookup</span><span class="p">[</span><span class="n">dpath</span><span class="p">]</span> <span class="o">=</span> <span class="n">did</span>
                <span class="k">if</span> <span class="n">spath</span> <span class="o">!=</span> <span class="n">dpath</span><span class="p">:</span>
                    <span class="n">adjacency</span><span class="p">[</span><span class="n">spath</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dpath</span><span class="p">)</span>

        <span class="c1"># Add nodes that do not overlap any images</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">adjacency</span><span class="p">,</span> <span class="n">node_id_map</span><span class="o">=</span><span class="n">adjacency_lookup</span><span class="p">)</span></div>

<div class="viewcode-block" id="NetworkCandidateGraph.clear_db"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.NetworkCandidateGraph.clear_db">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">clear_db</span><span class="p">(</span><span class="n">tables</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Truncate all of the database tables and reset any</span>
<span class="sd">        autoincrement columns to start with 1.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        table : str or list of str, optional</span>
<span class="sd">                the table name of a list of table names to truncate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
        <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span> <span class="c1"># In case any transactions are not done</span>
        <span class="k">if</span> <span class="n">tables</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tables</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">tables</span> <span class="o">=</span> <span class="p">[</span><span class="n">tables</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">table_names</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tables</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="s1">&#39;spatial_ref_sys&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ALTER SEQUENCE </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">_id_seq RESTART WITH 1&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Failed to truncate table </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1"> not modified&#39;</span><span class="p">)</span>
                <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
        <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">place_points_from_cnet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cnet</span><span class="p">):</span>
        <span class="n">semi_major</span><span class="p">,</span> <span class="n">semi_minor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;spatial&quot;</span><span class="p">][</span><span class="s2">&quot;semimajor_rad&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;spatial&quot;</span><span class="p">][</span><span class="s2">&quot;semiminor_rad&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cnet</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">cnet</span> <span class="o">=</span> <span class="n">from_isis</span><span class="p">(</span><span class="n">cnet</span><span class="p">)</span>

        <span class="n">cnetpoints</span> <span class="o">=</span> <span class="n">cnet</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">session</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span>

        <span class="k">for</span> <span class="nb">id</span><span class="p">,</span> <span class="n">cnetpoint</span> <span class="ow">in</span> <span class="n">cnetpoints</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">get_measures</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Images</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Images</span><span class="o">.</span><span class="n">serial</span> <span class="o">==</span> <span class="n">row</span><span class="o">.</span><span class="n">serialnumber</span><span class="p">)</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">Measures</span><span class="p">(</span><span class="n">pointid</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span>
                         <span class="n">imageid</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">id</span><span class="p">),</span> <span class="c1"># Need to grab this</span>
                         <span class="n">measuretype</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">measureType</span><span class="p">),</span>
                         <span class="n">serial</span><span class="o">=</span><span class="n">row</span><span class="o">.</span><span class="n">serialnumber</span><span class="p">,</span>
                         <span class="n">sample</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;sample&#39;</span><span class="p">]),</span>
                         <span class="n">line</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;line&#39;</span><span class="p">]),</span>
                         <span class="n">sampler</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">sampleResidual</span><span class="p">),</span>
                         <span class="n">liner</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">lineResidual</span><span class="p">),</span>
                         <span class="n">ignore</span><span class="o">=</span><span class="n">row</span><span class="o">.</span><span class="n">measureIgnore</span><span class="p">,</span>
                         <span class="n">jigreject</span><span class="o">=</span><span class="n">row</span><span class="o">.</span><span class="n">measureJigsawRejected</span><span class="p">,</span>
                         <span class="n">aprioriline</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">aprioriline</span><span class="p">),</span>
                         <span class="n">apriorisample</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">apriorisample</span><span class="p">),</span>
                         <span class="n">linesigma</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">linesigma</span><span class="p">),</span>
                         <span class="n">samplesigma</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">samplesigma</span><span class="p">))</span>

            <span class="n">measures</span> <span class="o">=</span> <span class="n">cnetpoint</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">get_measures</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">row</span> <span class="o">=</span> <span class="n">cnetpoint</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">adjustedX</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">adjustedY</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">adjustedZ</span>
            <span class="n">lon_og</span><span class="p">,</span> <span class="n">lat_og</span><span class="p">,</span> <span class="n">alt</span> <span class="o">=</span> <span class="n">reproject</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">semi_major</span><span class="p">,</span> <span class="n">semi_minor</span><span class="p">,</span> <span class="s1">&#39;geocent&#39;</span><span class="p">,</span> <span class="s1">&#39;latlon&#39;</span><span class="p">)</span>
            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">og2oc</span><span class="p">(</span><span class="n">lon_og</span><span class="p">,</span> <span class="n">lat_og</span><span class="p">,</span> <span class="n">semi_major</span><span class="p">,</span> <span class="n">semi_minor</span><span class="p">)</span>


            <span class="n">point</span> <span class="o">=</span> <span class="n">Points</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span>
                           <span class="n">ignore</span><span class="o">=</span><span class="n">row</span><span class="o">.</span><span class="n">pointIgnore</span><span class="p">,</span>
                           <span class="n">apriori</span><span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">aprioriX</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">aprioriY</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">aprioriZ</span><span class="p">)),</span>
                           <span class="n">adjusted</span><span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">adjustedX</span><span class="p">),</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">adjustedY</span><span class="p">),</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">adjustedZ</span><span class="p">)),</span>
                           <span class="n">pointtype</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">pointType</span><span class="p">))</span>

            <span class="n">point</span><span class="o">.</span><span class="n">measures</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">measures</span><span class="p">)</span>
            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="n">session</span><span class="o">.</span><span class="n">add_all</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<div class="viewcode-block" id="NetworkCandidateGraph.from_cnet"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.NetworkCandidateGraph.from_cnet">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_cnet</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cnet</span><span class="p">,</span> <span class="n">filelist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">networkobj</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_filelist</span><span class="p">(</span><span class="n">filelist</span><span class="p">)</span>
        <span class="n">networkobj</span><span class="o">.</span><span class="n">place_points_from_cnet</span><span class="p">(</span><span class="n">cnet</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">networkobj</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">measures</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql_table</span><span class="p">(</span><span class="s1">&#39;measures&#39;</span><span class="p">,</span> <span class="n">con</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">queue_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the length of the processing queue. Jobs are left on the</span>
<span class="sd">        queue if a cluster job is cancelled. Those cancelled jobs are then</span>
<span class="sd">        called on next cluster job launch, causing failures. This method provides</span>
<span class="sd">        a quick check for left over jobs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">llen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">redis_queue</span><span class="o">.</span><span class="n">llen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;redis&#39;</span><span class="p">][</span><span class="s1">&#39;processing_queue&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">llen</span>

<div class="viewcode-block" id="NetworkCandidateGraph.queue_flushdb"><a class="viewcode-back" href="../../../library/graph/network.html#autocnet.graph.network.NetworkCandidateGraph.queue_flushdb">[docs]</a>    <span class="k">def</span> <span class="nf">queue_flushdb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear the processing queue of any left over jobs from a previous cluster</span>
<span class="sd">        job cancellation or hanging jobs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">redis_queue</span><span class="o">.</span><span class="n">flushdb</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">cluster_propagate_control_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                          <span class="n">base_cnet</span><span class="p">,</span>
                                          <span class="n">walltime</span><span class="o">=</span><span class="s1">&#39;00:20:00&#39;</span><span class="p">,</span>
                                          <span class="n">chunksize</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                                          <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This function is not well tested. No tests currently exists </span><span class="se">\</span>
<span class="s1">        in the test suite for this version of the function.&#39;</span><span class="p">)</span>

        <span class="c1"># Setup the redis queue</span>
        <span class="n">rqueue</span> <span class="o">=</span> <span class="n">StrictRedis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;redis&#39;</span><span class="p">][</span><span class="s1">&#39;host&#39;</span><span class="p">],</span>
                             <span class="n">port</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;redis&#39;</span><span class="p">][</span><span class="s1">&#39;port&#39;</span><span class="p">],</span>
                             <span class="n">db</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Push the job messages onto the queue</span>
        <span class="n">queuename</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;redis&#39;</span><span class="p">][</span><span class="s1">&#39;processing_queue&#39;</span><span class="p">]</span>

        <span class="n">groups</span> <span class="o">=</span> <span class="n">base_cnet</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;pointid&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span>
        <span class="k">for</span> <span class="n">cpoint</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">measures</span> <span class="o">=</span> <span class="n">base_cnet</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="n">measure</span> <span class="o">=</span> <span class="n">measures</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">p</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">point</span>

            <span class="c1"># get image in the destination that overlap</span>
            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">measures</span><span class="p">[</span><span class="s2">&quot;point&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xy</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lon&#39;</span> <span class="p">:</span> <span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                   <span class="s1">&#39;lat&#39;</span> <span class="p">:</span> <span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                   <span class="s1">&#39;pointid&#39;</span> <span class="p">:</span> <span class="n">cpoint</span><span class="p">,</span>
                   <span class="s1">&#39;paths&#39;</span> <span class="p">:</span> <span class="n">measures</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                   <span class="s1">&#39;lines&#39;</span> <span class="p">:</span> <span class="n">measures</span><span class="p">[</span><span class="s1">&#39;line&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                   <span class="s1">&#39;samples&#39;</span> <span class="p">:</span> <span class="n">measures</span><span class="p">[</span><span class="s1">&#39;sample&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                   <span class="s1">&#39;walltime&#39;</span> <span class="p">:</span> <span class="n">walltime</span><span class="p">}</span>
            <span class="n">rqueue</span><span class="o">.</span><span class="n">rpush</span><span class="p">(</span><span class="n">queuename</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">JsonEncoder</span><span class="p">))</span>

        <span class="c1"># Submit the jobs</span>
        <span class="n">submitter</span> <span class="o">=</span> <span class="n">Slurm</span><span class="p">(</span><span class="s1">&#39;acn_propagate&#39;</span><span class="p">,</span>
                     <span class="n">job_name</span><span class="o">=</span><span class="s1">&#39;cross_instrument_matcher&#39;</span><span class="p">,</span>
                     <span class="n">mem_per_cpu</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">][</span><span class="s1">&#39;processing_memory&#39;</span><span class="p">],</span>
                     <span class="n">time</span><span class="o">=</span><span class="n">walltime</span><span class="p">,</span>
                     <span class="n">partition</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">][</span><span class="s1">&#39;queue&#39;</span><span class="p">],</span>
                     <span class="n">output</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">][</span><span class="s1">&#39;cluster_log_dir&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;/autocnet.cim-%j&#39;</span><span class="p">)</span>
        <span class="n">job_counter</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">submitter</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">array</span><span class="o">=</span><span class="s1">&#39;1-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">job_counter</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">job_counter</span>

    <span class="k">def</span> <span class="nf">subpixel_register_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">subpixel</span><span class="o">.</span><span class="n">subpixel_register_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Session</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">subpixel_register_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pointid</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">subpixel</span><span class="o">.</span><span class="n">subpixel_register_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Session</span><span class="p">,</span> <span class="n">pointid</span><span class="p">,</span> <span class="o">**</span><span class="n">kwarg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">subpixel_regiter_mearure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">measureid</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">subpixel</span><span class="o">.</span><span class="n">subpixel_register_measure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Session</span><span class="p">,</span> <span class="n">measureid</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">propagate_control_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">control_net</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">cim</span><span class="o">.</span><span class="n">propagate_control_network</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Session</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">dem</span><span class="p">,</span>
                                      <span class="n">control_net</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">generate_ground_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ground_mosaic</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">cim</span><span class="o">.</span><span class="n">generate_ground_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Session</span><span class="p">,</span> <span class="n">ground_mosaic</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">place_points_in_overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">overlap</span><span class="o">.</span><span class="n">place_points_in_overlaps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Session</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">dem</span><span class="p">,</span>
                                         <span class="n">nodes</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2017 - , AutoCNetDevelopers.
      </li>
      <li>
      Last updated on Jul 27, 2020.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 3.1.2.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>